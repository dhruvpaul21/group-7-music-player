{
  "version": 3,
  "sources": ["../../svelte-navigator/src/utils.js", "../../svelte-navigator/src/contexts.js", "../../svelte-navigator/src/paths.js", "../../svelte-navigator/src/warning.js", "../../svelte-navigator/src/routes.js", "../../svelte-navigator/src/history.js", "../../svelte-navigator/src/a11y.js", "../../svelte-navigator/src/Router.svelte", "../../svelte-navigator/src/hooks.js", "../../svelte-navigator/src/Route.svelte", "../../svelte-navigator/src/Link.svelte", "../../svelte-navigator/src/actions.js"],
  "sourcesContent": ["/*\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n */\n\nexport const isUndefined = value => typeof value === \"undefined\";\n\nexport const isFunction = value => typeof value === \"function\";\n\nexport const isNumber = value => typeof value === \"number\";\n\n/**\n * Decides whether a given `event` should result in a navigation or not.\n * @param {object} event\n */\nexport function shouldNavigate(event) {\n\treturn (\n\t\t!event.defaultPrevented &&\n\t\tevent.button === 0 &&\n\t\t!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n\t);\n}\n\nexport function createCounter() {\n\tlet i = 0;\n\t/**\n\t * Returns an id and increments the internal state\n\t * @returns {number}\n\t */\n\treturn () => i++;\n}\n\n/**\n * Create a globally unique id\n *\n * @returns {string} An id\n */\nexport function createGlobalId() {\n\treturn Math.random().toString(36).substring(2);\n}\n\nexport function findClosest(tagName, element) {\n\twhile (element && element.tagName !== tagName) {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\telement = element.parentNode;\n\t}\n\treturn element;\n}\n\nexport const isSSR = typeof window === \"undefined\";\n\nexport function addListener(target, type, handler) {\n\ttarget.addEventListener(type, handler);\n\treturn () => target.removeEventListener(type, handler);\n}\n\nexport const createInlineStyle = (disableInlineStyles, style) =>\n\tdisableInlineStyles ? {} : { style };\nexport const createMarkerProps = disableInlineStyles => ({\n\t\"aria-hidden\": \"true\",\n\t...createInlineStyle(disableInlineStyles, \"display:none;\"),\n});\n", "/*\n * Adapted from https://github.com/EmilTholin/svelte-routing\n *\n * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n */\n\nconst createKey = ctxName => `@@svnav-ctx__${ctxName}`;\n\n// Use strings instead of objects, so different versions of\n// svelte-navigator can potentially still work together\nexport const LOCATION = createKey(\"LOCATION\");\nexport const ROUTER = createKey(\"ROUTER\");\nexport const ROUTE = createKey(\"ROUTE\");\nexport const ROUTE_PARAMS = createKey(\"ROUTE_PARAMS\");\nexport const FOCUS_ELEM = createKey(\"FOCUS_ELEM\");\n", "export const paramRegex = /^:(.+)/;\n\nexport const substr = (str, start, end) => str.substr(start, end);\n\n/**\n * Check if `string` starts with `search`\n * @param {string} string\n * @param {string} search\n * @return {boolean}\n */\nexport const startsWith = (string, search) =>\n\tsubstr(string, 0, search.length) === search;\n\n/**\n * Check if `segment` is a root segment\n * @param {string} segment\n * @return {boolean}\n */\nexport const isRootSegment = segment => segment === \"\";\n\n/**\n * Check if `segment` is a dynamic segment\n * @param {string} segment\n * @return {boolean}\n */\nexport const isDynamic = segment => paramRegex.test(segment);\n\n/**\n * Check if `segment` is a splat\n * @param {string} segment\n * @return {boolean}\n */\nexport const isSplat = segment => segment[0] === \"*\";\n\n/**\n * Strip potention splat and splatname of the end of a path\n * @param {string} str\n * @return {string}\n */\nexport const stripSplat = str => str.replace(/\\*.*$/, \"\");\n\n/**\n * Strip `str` of potential start and end `/`\n * @param {string} str\n * @return {string}\n */\nexport const stripSlashes = str => str.replace(/(^\\/+|\\/+$)/g, \"\");\n\n/**\n * Split up the URI into segments delimited by `/`\n * @param {string} uri\n * @return {string[]}\n */\nexport function segmentize(uri, filterFalsy = false) {\n\tconst segments = stripSlashes(uri).split(\"/\");\n\treturn filterFalsy ? segments.filter(Boolean) : segments;\n}\n\n/**\n * Add the query to the pathname if a query is given\n * @param {string} pathname\n * @param {string} [query]\n * @return {string}\n */\nexport const addQuery = (pathname, query) =>\n\tpathname + (query ? `?${query}` : \"\");\n\n/**\n * Combines the `basepath` and the `path` into one path.\n * @param {string} basepath\n * @param {string} path\n */\nexport function combinePaths(basepath, path) {\n\tconst barePath =\n\t\tpath === \"/\" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`;\n\treturn `${stripSlashes(barePath)}/`;\n}\n\n/**\n * Normalizes a basepath\n *\n * @param {string} path\n * @returns {string}\n *\n * @example\n * normalizePath(\"base/path/\") // -> \"/base/path\"\n */\nexport const normalizePath = path => `/${stripSlashes(path)}`;\n\n/**\n * Joins and normalizes multiple path fragments\n *\n * @param {...string} pathFragments\n * @returns {string}\n */\nexport function join(...pathFragments) {\n\tconst joinFragment = fragment => segmentize(fragment, true).join(\"/\");\n\tconst joinedSegments = pathFragments.map(joinFragment).join(\"/\");\n\treturn normalizePath(joinedSegments);\n}\n", "import { isFunction } from \"./utils\";\n\n// We start from 1 here, so we can check if an origin id has been passed\n// by using `originId || <fallback>`\nexport const LINK_ID = 1;\nexport const ROUTE_ID = 2;\nexport const ROUTER_ID = 3;\nexport const USE_FOCUS_ID = 4;\nexport const USE_LOCATION_ID = 5;\nexport const USE_MATCH_ID = 6;\nexport const USE_NAVIGATE_ID = 7;\nexport const USE_PARAMS_ID = 8;\nexport const USE_RESOLVABLE_ID = 9;\nexport const USE_RESOLVE_ID = 10;\nexport const NAVIGATE_ID = 11;\n\nconst labels = {\n\t[LINK_ID]: \"Link\",\n\t[ROUTE_ID]: \"Route\",\n\t[ROUTER_ID]: \"Router\",\n\t[USE_FOCUS_ID]: \"useFocus\",\n\t[USE_LOCATION_ID]: \"useLocation\",\n\t[USE_MATCH_ID]: \"useMatch\",\n\t[USE_NAVIGATE_ID]: \"useNavigate\",\n\t[USE_PARAMS_ID]: \"useParams\",\n\t[USE_RESOLVABLE_ID]: \"useResolvable\",\n\t[USE_RESOLVE_ID]: \"useResolve\",\n\t[NAVIGATE_ID]: \"navigate\",\n};\n\nexport const createLabel = labelId => labels[labelId];\n\nexport function createIdentifier(labelId, props) {\n\tlet attr;\n\tif (labelId === ROUTE_ID) {\n\t\tattr = props.path ? `path=\"${props.path}\"` : \"default\";\n\t} else if (labelId === LINK_ID) {\n\t\tattr = `to=\"${props.to}\"`;\n\t} else if (labelId === ROUTER_ID) {\n\t\tattr = `basepath=\"${props.basepath || \"\"}\"`;\n\t}\n\treturn `<${createLabel(labelId)} ${attr || \"\"} />`;\n}\n\nexport function createMessage(labelId, message, props, originId) {\n\tconst origin = props && createIdentifier(originId || labelId, props);\n\tconst originMsg = origin ? `\\n\\nOccurred in: ${origin}` : \"\";\n\tconst label = createLabel(labelId);\n\tconst msg = isFunction(message) ? message(label) : message;\n\treturn `<${label}> ${msg}${originMsg}`;\n}\n\nexport const createMessageHandler =\n\thandler =>\n\t(...args) =>\n\t\thandler(createMessage(...args));\n\nexport const fail = createMessageHandler(message => {\n\tthrow new Error(message);\n});\n\n// eslint-disable-next-line no-console\nexport const warn = createMessageHandler(console.warn);\n", "import {\n\tsegmentize,\n\tjoin,\n\taddQuery,\n\tstartsWith,\n\tparamRegex,\n\tisSplat,\n\tisRootSegment,\n\tisDynamic,\n\tstripSplat,\n\tnormalizePath,\n\tsubstr,\n} from \"./paths\";\nimport { ROUTER_ID, fail } from \"./warning\";\nimport { isUndefined } from \"./utils\";\n\nconst SEGMENT_POINTS = 4;\nconst STATIC_POINTS = 3;\nconst DYNAMIC_POINTS = 2;\nconst SPLAT_PENALTY = 1;\nconst ROOT_POINTS = 1;\n\n/**\n * Score a route depending on how its individual segments look\n * @param {object} route\n * @param {number} index\n * @return {object}\n */\nexport function rankRoute(route, index) {\n\tconst score = route.default\n\t\t? 0\n\t\t: segmentize(route.fullPath).reduce((acc, segment) => {\n\t\t\t\tlet nextScore = acc;\n\t\t\t\tnextScore += SEGMENT_POINTS;\n\n\t\t\t\tif (isRootSegment(segment)) {\n\t\t\t\t\tnextScore += ROOT_POINTS;\n\t\t\t\t} else if (isDynamic(segment)) {\n\t\t\t\t\tnextScore += DYNAMIC_POINTS;\n\t\t\t\t} else if (isSplat(segment)) {\n\t\t\t\t\tnextScore -= SEGMENT_POINTS + SPLAT_PENALTY;\n\t\t\t\t} else {\n\t\t\t\t\tnextScore += STATIC_POINTS;\n\t\t\t\t}\n\n\t\t\t\treturn nextScore;\n\t\t  }, 0);\n\n\treturn { route, score, index };\n}\n\n/**\n * Give a score to all routes and sort them on that\n * @param {object[]} routes\n * @return {object[]}\n */\nexport function rankRoutes(routes) {\n\treturn (\n\t\troutes\n\t\t\t.map(rankRoute)\n\t\t\t// If two routes have the exact same score, we go by index instead\n\t\t\t.sort((a, b) => {\n\t\t\t\tif (a.score < b.score) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (a.score > b.score) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn a.index - b.index;\n\t\t\t})\n\t);\n}\n\n/**\n * Ranks and picks the best route to match. Each segment gets the highest\n * amount of points, then the type of segment gets an additional amount of\n * points where\n *\n *  static > dynamic > splat > root\n *\n * This way we don't have to worry about the order of our routes, let the\n * computers do it.\n *\n * A route looks like this\n *\n *  { fullPath, default, value }\n *\n * And a returned match looks like:\n *\n *  { route, params, uri }\n *\n * @param {object[]} routes\n * @param {string} uri\n * @return {?object}\n */\nexport function pick(routes, uri) {\n\tlet bestMatch;\n\tlet defaultMatch;\n\n\tconst [uriPathname] = uri.split(\"?\");\n\tconst uriSegments = segmentize(uriPathname);\n\tconst isRootUri = uriSegments[0] === \"\";\n\tconst ranked = rankRoutes(routes);\n\n\tfor (let i = 0, l = ranked.length; i < l; i++) {\n\t\tconst { route } = ranked[i];\n\t\tlet missed = false;\n\t\tconst params = {};\n\n\t\t// eslint-disable-next-line no-shadow\n\t\tconst createMatch = uri => ({ ...route, params, uri });\n\n\t\tif (route.default) {\n\t\t\tdefaultMatch = createMatch(uri);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst routeSegments = segmentize(route.fullPath);\n\t\tconst max = Math.max(uriSegments.length, routeSegments.length);\n\t\tlet index = 0;\n\n\t\tfor (; index < max; index++) {\n\t\t\tconst routeSegment = routeSegments[index];\n\t\t\tconst uriSegment = uriSegments[index];\n\n\t\t\tif (!isUndefined(routeSegment) && isSplat(routeSegment)) {\n\t\t\t\t// Hit a splat, just grab the rest, and return a match\n\t\t\t\t// uri:   /files/documents/work\n\t\t\t\t// route: /files/* or /files/*splatname\n\t\t\t\tconst splatName = routeSegment === \"*\" ? \"*\" : routeSegment.slice(1);\n\n\t\t\t\tparams[splatName] = uriSegments\n\t\t\t\t\t.slice(index)\n\t\t\t\t\t.map(decodeURIComponent)\n\t\t\t\t\t.join(\"/\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isUndefined(uriSegment)) {\n\t\t\t\t// URI is shorter than the route, no match\n\t\t\t\t// uri:   /users\n\t\t\t\t// route: /users/:userId\n\t\t\t\tmissed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst dynamicMatch = paramRegex.exec(routeSegment);\n\n\t\t\tif (dynamicMatch && !isRootUri) {\n\t\t\t\tconst value = decodeURIComponent(uriSegment);\n\t\t\t\tparams[dynamicMatch[1]] = value;\n\t\t\t} else if (routeSegment !== uriSegment) {\n\t\t\t\t// Current segments don't match, not dynamic, not splat, so no match\n\t\t\t\t// uri:   /users/123/settings\n\t\t\t\t// route: /users/:id/profile\n\t\t\t\tmissed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!missed) {\n\t\t\tbestMatch = createMatch(join(...uriSegments.slice(0, index)));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bestMatch || defaultMatch || null;\n}\n\n/**\n * Check if the `route.fullPath` matches the `uri`.\n * @param {Object} route\n * @param {string} uri\n * @return {?object}\n */\nexport function match(route, uri) {\n\treturn pick([route], uri);\n}\n\n/**\n * Resolve URIs as though every path is a directory, no files. Relative URIs\n * in the browser can feel awkward because not only can you be \"in a directory\",\n * you can be \"at a file\", too. For example:\n *\n *  browserSpecResolve('foo', '/bar/') => /bar/foo\n *  browserSpecResolve('foo', '/bar') => /foo\n *\n * But on the command line of a file system, it's not as complicated. You can't\n * `cd` from a file, only directories. This way, links have to know less about\n * their current path. To go deeper you can do this:\n *\n *  <Link to=\"deeper\"/>\n *  // instead of\n *  <Link to=`{${props.uri}/deeper}`/>\n *\n * Just like `cd`, if you want to go deeper from the command line, you do this:\n *\n *  cd deeper\n *  # not\n *  cd $(pwd)/deeper\n *\n * By treating every path as a directory, linking to relative paths should\n * require less contextual information and (fingers crossed) be more intuitive.\n * @param {string} to\n * @param {string} base\n * @return {string}\n */\nexport function resolve(to, base) {\n\t// /foo/bar, /baz/qux => /foo/bar\n\tif (startsWith(to, \"/\")) {\n\t\treturn to;\n\t}\n\n\tconst [toPathname, toQuery] = to.split(\"?\");\n\tconst [basePathname] = base.split(\"?\");\n\tconst toSegments = segmentize(toPathname);\n\tconst baseSegments = segmentize(basePathname);\n\n\t// ?a=b, /users?b=c => /users?a=b\n\tif (toSegments[0] === \"\") {\n\t\treturn addQuery(basePathname, toQuery);\n\t}\n\n\t// profile, /users/789 => /users/789/profile\n\tif (!startsWith(toSegments[0], \".\")) {\n\t\tconst pathname = baseSegments.concat(toSegments).join(\"/\");\n\t\treturn addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n\t}\n\n\t// ./       , /users/123 => /users/123\n\t// ../      , /users/123 => /users\n\t// ../..    , /users/123 => /\n\t// ../../one, /a/b/c/d   => /a/b/one\n\t// .././one , /a/b/c/d   => /a/b/c/one\n\tconst allSegments = baseSegments.concat(toSegments);\n\tconst segments = [];\n\n\tallSegments.forEach(segment => {\n\t\tif (segment === \"..\") {\n\t\t\tsegments.pop();\n\t\t} else if (segment !== \".\") {\n\t\t\tsegments.push(segment);\n\t\t}\n\t});\n\n\treturn addQuery(`/${segments.join(\"/\")}`, toQuery);\n}\n\n/**\n * Normalizes a location for consumption by `Route` children and the `Router`.\n * It removes the apps basepath from the pathname\n * and sets default values for `search` and `hash` properties.\n *\n * @param {Object} location The current global location supplied by the history component\n * @param {string} basepath The applications basepath (i.e. when serving from a subdirectory)\n *\n * @returns The normalized location\n */\nexport function normalizeLocation(location, basepath) {\n\tconst { pathname, hash = \"\", search = \"\", state } = location;\n\tconst baseSegments = segmentize(basepath, true);\n\tconst pathSegments = segmentize(pathname, true);\n\twhile (baseSegments.length) {\n\t\tif (baseSegments[0] !== pathSegments[0]) {\n\t\t\tfail(\n\t\t\t\tROUTER_ID,\n\t\t\t\t`Invalid state: All locations must begin with the basepath \"${basepath}\", found \"${pathname}\"`,\n\t\t\t);\n\t\t}\n\t\tbaseSegments.shift();\n\t\tpathSegments.shift();\n\t}\n\treturn {\n\t\tpathname: join(...pathSegments),\n\t\thash,\n\t\tsearch,\n\t\tstate,\n\t};\n}\n\nconst normalizeUrlFragment = frag => (frag.length === 1 ? \"\" : frag);\n\n/**\n * Creates a location object from an url.\n * It is used to create a location from the url prop used in SSR\n *\n * @param {string} url The url string (e.g. \"/path/to/somewhere\")\n * @returns {{ pathname: string; search: string; hash: string }} The location\n *\n * @example\n * ```js\n * const path = \"/search?q=falafel#result-3\";\n * const location = parsePath(path);\n * // -> {\n * //   pathname: \"/search\",\n * //   search: \"?q=falafel\",\n * //   hash: \"#result-3\",\n * // };\n * ```\n */\nexport const parsePath = path => {\n\tconst searchIndex = path.indexOf(\"?\");\n\tconst hashIndex = path.indexOf(\"#\");\n\tconst hasSearchIndex = searchIndex !== -1;\n\tconst hasHashIndex = hashIndex !== -1;\n\tconst hash = hasHashIndex\n\t\t? normalizeUrlFragment(substr(path, hashIndex))\n\t\t: \"\";\n\tconst pathnameAndSearch = hasHashIndex ? substr(path, 0, hashIndex) : path;\n\tconst search = hasSearchIndex\n\t\t? normalizeUrlFragment(substr(pathnameAndSearch, searchIndex))\n\t\t: \"\";\n\tconst pathname =\n\t\t(hasSearchIndex\n\t\t\t? substr(pathnameAndSearch, 0, searchIndex)\n\t\t\t: pathnameAndSearch) || \"/\";\n\treturn { pathname, search, hash };\n};\n\n/**\n * Joins a location object to one path string.\n *\n * @param {{ pathname: string; search: string; hash: string }} location The location object\n * @returns {string} A path, created from the location\n *\n * @example\n * ```js\n * const location = {\n *   pathname: \"/search\",\n *   search: \"?q=falafel\",\n *   hash: \"#result-3\",\n * };\n * const path = stringifyPath(location);\n * // -> \"/search?q=falafel#result-3\"\n * ```\n */\nexport const stringifyPath = location => {\n\tconst { pathname, search, hash } = location;\n\treturn pathname + search + hash;\n};\n\n/**\n * Resolves a link relative to the parent Route and the Routers basepath.\n *\n * @param {string} path The given path, that will be resolved\n * @param {string} routeBase The current Routes base path\n * @param {string} appBase The basepath of the app. Used, when serving from a subdirectory\n * @returns {string} The resolved path\n *\n * @example\n * resolveLink(\"relative\", \"/routeBase\", \"/\") // -> \"/routeBase/relative\"\n * resolveLink(\"/absolute\", \"/routeBase\", \"/\") // -> \"/absolute\"\n * resolveLink(\"relative\", \"/routeBase\", \"/base\") // -> \"/base/routeBase/relative\"\n * resolveLink(\"/absolute\", \"/routeBase\", \"/base\") // -> \"/base/absolute\"\n */\nexport function resolveLink(path, routeBase, appBase) {\n\treturn join(appBase, resolve(path, routeBase));\n}\n\n/**\n * Get the uri for a Route, by matching it against the current location.\n *\n * @param {string} routePath The Routes resolved path\n * @param {string} pathname The current locations pathname\n */\nexport function extractBaseUri(routePath, pathname) {\n\tconst fullPath = normalizePath(stripSplat(routePath));\n\tconst baseSegments = segmentize(fullPath, true);\n\tconst pathSegments = segmentize(pathname, true).slice(0, baseSegments.length);\n\tconst routeMatch = match({ fullPath }, join(...pathSegments));\n\treturn routeMatch && routeMatch.uri;\n}\n", "/*\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n */\n\nimport { parsePath } from \"./routes\";\nimport { createGlobalId, isSSR, isNumber, addListener } from \"./utils\";\nimport { warn, NAVIGATE_ID } from \"./warning\";\n\nconst POP = \"POP\";\nconst PUSH = \"PUSH\";\nconst REPLACE = \"REPLACE\";\n\nfunction getLocation(source) {\n\treturn {\n\t\t...source.location,\n\t\tpathname: encodeURI(decodeURI(source.location.pathname)),\n\t\tstate: source.history.state,\n\t\t_key: (source.history.state && source.history.state._key) || \"initial\",\n\t};\n}\n\nfunction createHistory(source) {\n\tlet listeners = [];\n\tlet location = getLocation(source);\n\tlet action = POP;\n\n\tconst notifyListeners = (listenerFns = listeners) =>\n\t\tlistenerFns.forEach(listener => listener({ location, action }));\n\n\treturn {\n\t\tget location() {\n\t\t\treturn location;\n\t\t},\n\t\tlisten(listener) {\n\t\t\tlisteners.push(listener);\n\n\t\t\tconst popstateListener = () => {\n\t\t\t\tlocation = getLocation(source);\n\t\t\t\taction = POP;\n\t\t\t\tnotifyListeners([listener]);\n\t\t\t};\n\n\t\t\t// Call listener when it is registered\n\t\t\tnotifyListeners([listener]);\n\n\t\t\tconst unlisten = addListener(source, \"popstate\", popstateListener);\n\t\t\treturn () => {\n\t\t\t\tunlisten();\n\t\t\t\tlisteners = listeners.filter(fn => fn !== listener);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * Navigate to a new absolute route.\n\t\t *\n\t\t * @param {string|number} to The path to navigate to.\n\t\t *\n\t\t * If `to` is a number we will navigate to the stack entry index + `to`\n\t\t * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)\n\t\t * @param {Object} options\n\t\t * @param {*} [options.state] The state will be accessible through `location.state`\n\t\t * @param {boolean} [options.replace=false] Replace the current entry in the history\n\t\t * stack, instead of pushing on a new one\n\t\t */\n\t\tnavigate(to, options) {\n\t\t\tconst { state = {}, replace = false } = options || {};\n\t\t\taction = replace ? REPLACE : PUSH;\n\t\t\tif (isNumber(to)) {\n\t\t\t\tif (options) {\n\t\t\t\t\twarn(\n\t\t\t\t\t\tNAVIGATE_ID,\n\t\t\t\t\t\t\"Navigation options (state or replace) are not supported, \" +\n\t\t\t\t\t\t\t\"when passing a number as the first argument to navigate. \" +\n\t\t\t\t\t\t\t\"They are ignored.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\taction = POP;\n\t\t\t\tsource.history.go(to);\n\t\t\t} else {\n\t\t\t\tconst keyedState = { ...state, _key: createGlobalId() };\n\t\t\t\t// try...catch iOS Safari limits to 100 pushState calls\n\t\t\t\ttry {\n\t\t\t\t\tsource.history[replace ? \"replaceState\" : \"pushState\"](\n\t\t\t\t\t\tkeyedState,\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t\tto,\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tsource.location[replace ? \"replace\" : \"assign\"](to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocation = getLocation(source);\n\t\t\tnotifyListeners();\n\t\t},\n\t};\n}\n\nfunction createStackFrame(state, uri) {\n\treturn { ...parsePath(uri), state };\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nfunction createMemorySource(initialPathname = \"/\") {\n\tlet index = 0;\n\tlet stack = [createStackFrame(null, initialPathname)];\n\n\treturn {\n\t\t// This is just for testing...\n\t\tget entries() {\n\t\t\treturn stack;\n\t\t},\n\t\tget location() {\n\t\t\treturn stack[index];\n\t\t},\n\t\taddEventListener() {},\n\t\tremoveEventListener() {},\n\t\thistory: {\n\t\t\tget state() {\n\t\t\t\treturn stack[index].state;\n\t\t\t},\n\t\t\tpushState(state, title, uri) {\n\t\t\t\tindex++;\n\t\t\t\t// Throw away anything in the stack with an index greater than the current index.\n\t\t\t\t// This happens, when we go back using `go(-n)`. The index is now less than `stack.length`.\n\t\t\t\t// If we call `go(+n)` the stack entries with an index greater than the current index can\n\t\t\t\t// be reused.\n\t\t\t\t// However, if we navigate to a path, instead of a number, we want to create a new branch\n\t\t\t\t// of navigation.\n\t\t\t\tstack = stack.slice(0, index);\n\t\t\t\tstack.push(createStackFrame(state, uri));\n\t\t\t},\n\t\t\treplaceState(state, title, uri) {\n\t\t\t\tstack[index] = createStackFrame(state, uri);\n\t\t\t},\n\t\t\tgo(to) {\n\t\t\t\tconst newIndex = index + to;\n\t\t\t\tif (newIndex < 0 || newIndex > stack.length - 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tindex = newIndex;\n\t\t\t},\n\t\t},\n\t};\n}\n\n// Global history uses window.history as the source if available,\n// otherwise a memory history\nconst canUseDOM = !!(\n\t!isSSR &&\n\twindow.document &&\n\twindow.document.createElement\n);\n// Use memory history in iframes (for example in Svelte REPL)\nconst isEmbeddedPage = !isSSR && window.location.origin === \"null\";\nconst globalHistory = createHistory(\n\tcanUseDOM && !isEmbeddedPage ? window : createMemorySource(),\n);\nconst { navigate } = globalHistory;\n\nexport { globalHistory, navigate, createHistory, createMemorySource };\n", "import { get } from \"svelte/store\";\nimport { tick } from \"svelte\";\nimport { warn, ROUTER_ID, ROUTE_ID } from \"./warning\";\nimport { addListener } from \"./utils\";\n\n// We need to keep the focus candidate in a separate file, so svelte does\n// not update, when we mutate it.\n// Also, we need a single global reference, because taking focus needs to\n// work globally, even if we have multiple top level routers\n// eslint-disable-next-line import/no-mutable-exports\nexport let focusCandidate = null;\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let initialNavigation = true;\n\n/**\n * Check if RouterA is above RouterB in the document\n * @param {number} routerIdA The first Routers id\n * @param {number} routerIdB The second Routers id\n */\nfunction isAbove(routerIdA, routerIdB) {\n\tconst routerMarkers = document.querySelectorAll(\"[data-svnav-router]\");\n\tfor (let i = 0; i < routerMarkers.length; i++) {\n\t\tconst node = routerMarkers[i];\n\t\tconst currentId = Number(node.dataset.svnavRouter);\n\t\tif (currentId === routerIdA) return true;\n\t\tif (currentId === routerIdB) return false;\n\t}\n\treturn false;\n}\n\n/**\n * Check if a Route candidate is the best choice to move focus to,\n * and store the best match.\n * @param {{\n     level: number;\n     routerId: number;\n     route: {\n       id: number;\n       focusElement: import(\"svelte/store\").Readable<Promise<Element>|null>;\n     }\n   }} item A Route candidate, that updated and is visible after a navigation\n */\nexport function pushFocusCandidate(item) {\n\tif (\n\t\t// Best candidate if it's the only candidate...\n\t\t!focusCandidate ||\n\t\t// Route is nested deeper, than previous candidate\n\t\t// -> Route change was triggered in the deepest affected\n\t\t// Route, so that's were focus should move to\n\t\titem.level > focusCandidate.level ||\n\t\t// If the level is identical, we want to focus the first Route in the document,\n\t\t// so we pick the first Router lookin from page top to page bottom.\n\t\t(item.level === focusCandidate.level &&\n\t\t\tisAbove(item.routerId, focusCandidate.routerId))\n\t) {\n\t\tfocusCandidate = item;\n\t}\n}\n\n/**\n * Reset the focus candidate.\n */\nexport function clearFocusCandidate() {\n\tfocusCandidate = null;\n}\n\nexport function initialNavigationOccurred() {\n\tinitialNavigation = false;\n}\n\n/*\n * `focus` Adapted from https://github.com/oaf-project/oaf-side-effects/blob/master/src/index.ts\n *\n * https://github.com/oaf-project/oaf-side-effects/blob/master/LICENSE\n */\nexport function focus(elem) {\n\tif (!elem) return false;\n\tconst TABINDEX = \"tabindex\";\n\ttry {\n\t\tif (!elem.hasAttribute(TABINDEX)) {\n\t\t\telem.setAttribute(TABINDEX, \"-1\");\n\t\t\tlet unlisten;\n\t\t\t// We remove tabindex after blur to avoid weird browser behavior\n\t\t\t// where a mouse click can activate elements with tabindex=\"-1\".\n\t\t\tconst blurListener = () => {\n\t\t\t\telem.removeAttribute(TABINDEX);\n\t\t\t\tunlisten();\n\t\t\t};\n\t\t\tunlisten = addListener(elem, \"blur\", blurListener);\n\t\t}\n\t\telem.focus();\n\t\treturn document.activeElement === elem;\n\t} catch (e) {\n\t\t// Apparently trying to focus a disabled element in IE can throw.\n\t\t// See https://stackoverflow.com/a/1600194/2476884\n\t\treturn false;\n\t}\n}\n\nexport function isEndMarker(elem, id) {\n\treturn Number(elem.dataset.svnavRouteEnd) === id;\n}\n\nexport function isHeading(elem) {\n\treturn /^H[1-6]$/i.test(elem.tagName);\n}\n\nfunction query(selector, parent = document) {\n\treturn parent.querySelector(selector);\n}\n\nexport function queryHeading(id) {\n\tconst marker = query(`[data-svnav-route-start=\"${id}\"]`);\n\tlet current = marker.nextElementSibling;\n\twhile (!isEndMarker(current, id)) {\n\t\tif (isHeading(current)) {\n\t\t\treturn current;\n\t\t}\n\t\tconst heading = query(\"h1,h2,h3,h4,h5,h6\", current);\n\t\tif (heading) {\n\t\t\treturn heading;\n\t\t}\n\t\tcurrent = current.nextElementSibling;\n\t}\n\treturn null;\n}\n\nexport function handleFocus(route) {\n\tPromise.resolve(get(route.focusElement)).then(elem => {\n\t\tconst focusElement = elem || queryHeading(route.id);\n\t\tif (!focusElement) {\n\t\t\twarn(\n\t\t\t\tROUTER_ID,\n\t\t\t\t\"Could not find an element to focus. \" +\n\t\t\t\t\t\"You should always render a header for accessibility reasons, \" +\n\t\t\t\t\t'or set a custom focus element via the \"useFocus\" hook. ' +\n\t\t\t\t\t\"If you don't want this Route or Router to manage focus, \" +\n\t\t\t\t\t'pass \"primary={false}\" to it.',\n\t\t\t\troute,\n\t\t\t\tROUTE_ID,\n\t\t\t);\n\t\t}\n\t\tconst headingFocused = focus(focusElement);\n\t\tif (headingFocused) return;\n\t\tfocus(document.documentElement);\n\t});\n}\n\nexport const createTriggerFocus =\n\t(a11yConfig, announcementText, location) =>\n\t(manageFocus, announceNavigation) =>\n\t\t// Wait until the dom is updated, so we can look for headings\n\t\ttick().then(() => {\n\t\t\tif (!focusCandidate || initialNavigation) {\n\t\t\t\tinitialNavigationOccurred();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (manageFocus) {\n\t\t\t\thandleFocus(focusCandidate.route);\n\t\t\t}\n\t\t\tif (a11yConfig.announcements && announceNavigation) {\n\t\t\t\tconst { path, fullPath, meta, params, uri } = focusCandidate.route;\n\t\t\t\tconst announcementMessage = a11yConfig.createAnnouncement(\n\t\t\t\t\t{ path, fullPath, meta, params, uri },\n\t\t\t\t\tget(location),\n\t\t\t\t);\n\t\t\t\tPromise.resolve(announcementMessage).then(message => {\n\t\t\t\t\tannouncementText.set(message);\n\t\t\t\t});\n\t\t\t}\n\t\t\tclearFocusCandidate();\n\t\t});\n\nexport const visuallyHiddenStyle =\n\t\"position:fixed;\" +\n\t\"top:-1px;\" +\n\t\"left:0;\" +\n\t\"width:1px;\" +\n\t\"height:1px;\" +\n\t\"padding:0;\" +\n\t\"overflow:hidden;\" +\n\t\"clip:rect(0,0,0,0);\" +\n\t\"white-space:nowrap;\" +\n\t\"border:0;\";\n", "<script context=\"module\">\n\t// eslint-disable-next-line import/order\n\timport { createCounter, createInlineStyle, createMarkerProps } from \"./utils\";\n\n\tconst createId = createCounter();\n</script>\n\n<script>\n\t/*\n\t * Adapted from https://github.com/EmilTholin/svelte-routing\n\t *\n\t * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n\t */\n\n\timport { getContext, setContext, onMount } from \"svelte\";\n\timport { writable } from \"svelte/store\";\n\timport { LOCATION, ROUTER } from \"./contexts\";\n\timport { globalHistory } from \"./history\";\n\timport { normalizePath } from \"./paths\";\n\timport { pick, match, normalizeLocation, parsePath } from \"./routes\";\n\timport { isSSR } from \"./utils\";\n\timport { warn, ROUTER_ID } from \"./warning\";\n\timport {\n\t\tpushFocusCandidate,\n\t\tvisuallyHiddenStyle,\n\t\tcreateTriggerFocus,\n\t} from \"./a11y\";\n\n\tconst defaultBasepath = \"/\";\n\n\texport let basepath = defaultBasepath;\n\texport let url = null;\n\texport let history = globalHistory;\n\texport let primary = true;\n\texport let a11y = {};\n\texport let disableInlineStyles = false;\n\n\tconst a11yConfig = {\n\t\tcreateAnnouncement: route => `Navigated to ${route.uri}`,\n\t\tannouncements: true,\n\t\t...a11y,\n\t};\n\n\t// Remember the initial `basepath`, so we can fire a warning\n\t// when the user changes it later\n\tconst initialBasepath = basepath;\n\tconst normalizedBasepath = normalizePath(basepath);\n\n\tconst locationContext = getContext(LOCATION);\n\tconst routerContext = getContext(ROUTER);\n\n\tconst isTopLevelRouter = !locationContext;\n\tconst routerId = createId();\n\n\tconst manageFocus = primary && !(routerContext && !routerContext.manageFocus);\n\tconst announcementText = writable(\"\");\n\n\tconst shouldDisableInlineStyles = routerContext\n\t\t? routerContext.disableInlineStyles\n\t\t: disableInlineStyles;\n\n\tconst routes = writable([]);\n\tconst activeRoute = writable(null);\n\t// Used in SSR to synchronously set that a Route is active.\n\tlet hasActiveRoute = false;\n\n\t// Nesting level of router.\n\t// We will need this to identify sibling routers, when moving\n\t// focus on navigation, so we can focus the first possible router\n\tconst level = isTopLevelRouter ? 0 : routerContext.level + 1;\n\n\t// If we're running an SSR we force the location to the `url` prop\n\tconst getInitialLocation = () =>\n\t\tnormalizeLocation(\n\t\t\tisSSR ? parsePath(url) : history.location,\n\t\t\tnormalizedBasepath,\n\t\t);\n\tconst location = isTopLevelRouter\n\t\t? writable(getInitialLocation())\n\t\t: locationContext;\n\tconst prevLocation = writable($location);\n\n\tconst triggerFocus = createTriggerFocus(\n\t\ta11yConfig,\n\t\tannouncementText,\n\t\tlocation,\n\t);\n\n\tconst createRouteFilter = routeId => routeList =>\n\t\trouteList.filter(routeItem => routeItem.id !== routeId);\n\n\tfunction registerRoute(route) {\n\t\tif (isSSR) {\n\t\t\t// In SSR we should set the activeRoute immediately if it is a match.\n\t\t\t// If there are more Routes being registered after a match is found,\n\t\t\t// we just skip them.\n\t\t\tif (hasActiveRoute) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst matchingRoute = match(route, $location.pathname);\n\t\t\tif (matchingRoute) {\n\t\t\t\thasActiveRoute = true;\n\t\t\t\t// Return the match in SSR mode, so the matched Route can use it immediatly.\n\t\t\t\t// Waiting for activeRoute to update does not work, because it updates\n\t\t\t\t// after the Route is initialized\n\t\t\t\treturn matchingRoute; // eslint-disable-line consistent-return\n\t\t\t}\n\t\t} else {\n\t\t\troutes.update(prevRoutes => {\n\t\t\t\t// Remove an old version of the updated route,\n\t\t\t\t// before pushing the new version\n\t\t\t\tconst nextRoutes = createRouteFilter(route.id)(prevRoutes);\n\t\t\t\tnextRoutes.push(route);\n\t\t\t\treturn nextRoutes;\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction unregisterRoute(routeId) {\n\t\troutes.update(createRouteFilter(routeId));\n\t}\n\n\tif (!isTopLevelRouter && basepath !== defaultBasepath) {\n\t\twarn(\n\t\t\tROUTER_ID,\n\t\t\t'Only top-level Routers can have a \"basepath\" prop. It is ignored.',\n\t\t\t{ basepath },\n\t\t);\n\t}\n\t$: if (basepath !== initialBasepath) {\n\t\twarn(ROUTER_ID, 'You cannot change the \"basepath\" prop. It is ignored.');\n\t}\n\n\t// This reactive statement will be run when the Router is created\n\t// when there are no Routes and then again the following tick, so it\n\t// will not find an active Route in SSR and in the browser it will only\n\t// pick an active Route after all Routes have been registered.\n\t$: {\n\t\tconst bestMatch = pick($routes, $location.pathname);\n\t\tactiveRoute.set(bestMatch);\n\t}\n\n\t// Manage focus and announce navigation to screen reader users\n\t$: {\n\t\tif (isTopLevelRouter) {\n\t\t\tconst hasHash = !!$location.hash;\n\t\t\t// When a hash is present in the url, we skip focus management, because\n\t\t\t// focusing a different element will prevent in-page jumps (See #3)\n\t\t\tconst shouldManageFocus = !hasHash && manageFocus;\n\t\t\t// We don't want to make an announcement, when the hash changes,\n\t\t\t// but the active route stays the same\n\t\t\tconst announceNavigation =\n\t\t\t\t!hasHash || $location.pathname !== $prevLocation.pathname;\n\t\t\ttriggerFocus(shouldManageFocus, announceNavigation);\n\t\t}\n\t}\n\n\t// Queue matched Route, so top level Router can decide which Route to focus.\n\t// Non primary Routers should just be ignored\n\t$: if (manageFocus && $activeRoute && $activeRoute.primary) {\n\t\tpushFocusCandidate({ level, routerId, route: $activeRoute });\n\t}\n\n\tif (isTopLevelRouter) {\n\t\t// The topmost Router in the tree is responsible for updating\n\t\t// the location store and supplying it through context.\n\t\tonMount(() => {\n\t\t\tconst unlisten = history.listen(changedHistory => {\n\t\t\t\tconst normalizedLocation = normalizeLocation(\n\t\t\t\t\tchangedHistory.location,\n\t\t\t\t\tnormalizedBasepath,\n\t\t\t\t);\n\t\t\t\tprevLocation.set($location);\n\t\t\t\tlocation.set(normalizedLocation);\n\t\t\t});\n\n\t\t\treturn unlisten;\n\t\t});\n\n\t\tsetContext(LOCATION, location);\n\t}\n\n\tsetContext(ROUTER, {\n\t\tactiveRoute,\n\t\tregisterRoute,\n\t\tunregisterRoute,\n\t\tmanageFocus,\n\t\tlevel,\n\t\tid: routerId,\n\t\thistory: isTopLevelRouter ? history : routerContext.history,\n\t\tbasepath: isTopLevelRouter ? normalizedBasepath : routerContext.basepath,\n\t\tdisableInlineStyles: shouldDisableInlineStyles,\n\t});\n</script>\n\n<div\n\t{...createMarkerProps(shouldDisableInlineStyles)}\n\tdata-svnav-router={routerId}\n/>\n\n<slot />\n\n{#if isTopLevelRouter && manageFocus && a11yConfig.announcements}\n\t<div\n\t\trole=\"status\"\n\t\taria-atomic=\"true\"\n\t\taria-live=\"polite\"\n\t\tdata-svnav-announcer\n\t\t{...createInlineStyle(shouldDisableInlineStyles, visuallyHiddenStyle)}\n\t>\n\t\t{$announcementText}\n\t</div>\n{/if}\n", "import { getContext, onDestroy, tick } from \"svelte\";\nimport { derived, get, writable } from \"svelte/store\";\nimport { LOCATION, ROUTER, ROUTE, ROUTE_PARAMS, FOCUS_ELEM } from \"./contexts\";\nimport { resolveLink, match, normalizeLocation } from \"./routes\";\nimport { isNumber } from \"./utils\";\nimport {\n\tfail,\n\tcreateLabel,\n\tUSE_FOCUS_ID,\n\tROUTER_ID,\n\tUSE_LOCATION_ID,\n\tROUTE_ID,\n\tUSE_RESOLVE_ID,\n\tUSE_RESOLVABLE_ID,\n\tUSE_NAVIGATE_ID,\n\tUSE_MATCH_ID,\n\tUSE_PARAMS_ID,\n} from \"./warning\";\n\n/**\n * Check if a component or hook have been created outside of a\n * context providing component\n * @param {number} componentId\n * @param {*} props\n * @param {string?} ctxKey\n * @param {number?} ctxProviderId\n */\nexport function usePreflightCheck(\n\tcomponentId,\n\tprops,\n\tctxKey = ROUTER,\n\tctxProviderId = ROUTER_ID,\n) {\n\tconst ctx = getContext(ctxKey);\n\tif (!ctx) {\n\t\tfail(\n\t\t\tcomponentId,\n\t\t\tlabel =>\n\t\t\t\t`You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`,\n\t\t\tprops,\n\t\t);\n\t}\n}\n\nconst toReadonly = ctx => {\n\tconst { subscribe } = getContext(ctx);\n\treturn { subscribe };\n};\n\n/**\n * Access the current location via a readable store.\n * @returns {import(\"svelte/store\").Readable<{\n    pathname: string;\n    search: string;\n    hash: string;\n    state: {};\n  }>}\n *\n * @example\n  ```html\n  <script>\n    import { useLocation } from \"svelte-navigator\";\n\n    const location = useLocation();\n\n    $: console.log($location);\n    // {\n    //   pathname: \"/blog\",\n    //   search: \"?id=123\",\n    //   hash: \"#comments\",\n    //   state: {}\n    // }\n  </script>\n  ```\n */\nexport function useLocation() {\n\tusePreflightCheck(USE_LOCATION_ID);\n\treturn toReadonly(LOCATION);\n}\n\n/**\n * @typedef {{\n    path: string;\n    fullPath: string;\n    uri: string;\n    params: {};\n  }} RouteMatch\n */\n\n/**\n * @typedef {import(\"svelte/store\").Readable<RouteMatch|null>} RouteMatchStore\n */\n\n/**\n * Access the history of top level Router.\n */\nexport function useHistory() {\n\tconst { history } = getContext(ROUTER);\n\treturn history;\n}\n\n/**\n * Access the base of the parent Route.\n */\nexport function useRouteBase() {\n\tconst route = getContext(ROUTE);\n\treturn route ? derived(route, _route => _route.base) : writable(\"/\");\n}\n\n/**\n * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.\n * It is used under the hood in `Link` and `useNavigate`.\n * You can use it to manually resolve links, when using the `link` or `links` actions.\n *\n * @returns {(path: string) => string}\n *\n * @example\n  ```html\n  <script>\n    import { link, useResolve } from \"svelte-navigator\";\n\n    const resolve = useResolve();\n    // `resolvedLink` will be resolved relative to its parent Route\n    // and the Routers `basepath`\n    const resolvedLink = resolve(\"relativePath\");\n  </script>\n\n  <a href={resolvedLink} use:link>Relative link</a>\n  ```\n */\nexport function useResolve() {\n\tusePreflightCheck(USE_RESOLVE_ID);\n\tconst routeBase = useRouteBase();\n\tconst { basepath: appBase } = getContext(ROUTER);\n\t/**\n\t * Resolves the path relative to the current route and basepath.\n\t *\n\t * @param {string} path The path to resolve\n\t * @returns {string} The resolved path\n\t */\n\tconst resolve = path => resolveLink(path, get(routeBase), appBase);\n\treturn resolve;\n}\n\n/**\n * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.\n * It is used under the hood in `Link` and `useNavigate`.\n * You can use it to manually resolve links, when using the `link` or `links` actions.\n *\n * @returns {import(\"svelte/store\").Readable<string>}\n *\n * @example\n  ```html\n  <script>\n    import { link, useResolvable } from \"svelte-navigator\";\n\n    // `resolvedLink` will be resolved relative to its parent Route\n    // and the Routers `basepath`.\n    const resolvedLink = useResolvable(\"relativePath\");\n  </script>\n\n  <a href={$resolvedLink} use:link>Relative link</a>\n  ```\n */\nexport function useResolvable(path) {\n\tusePreflightCheck(USE_RESOLVABLE_ID);\n\tconst routeBase = useRouteBase();\n\tconst { basepath: appBase } = getContext(ROUTER);\n\treturn derived(routeBase, _routeBase =>\n\t\tresolveLink(path, _routeBase, appBase),\n\t);\n}\n\n/**\n * A hook, that returns a context-aware version of `navigate`.\n * It will automatically resolve the given link relative to the current Route.\n * It will also resolve a link against the `basepath` of the Router.\n *\n * @example\n  ```html\n  <!-- App.svelte -->\n  <script>\n    import { link, Route } from \"svelte-navigator\";\n    import RouteComponent from \"./RouteComponent.svelte\";\n  </script>\n\n  <Router>\n    <Route path=\"route1\">\n      <RouteComponent />\n    </Route>\n    <!-- ... -->\n  </Router>\n\n  <!-- RouteComponent.svelte -->\n  <script>\n    import { useNavigate } from \"svelte-navigator\";\n\n    const navigate = useNavigate();\n  </script>\n\n  <button on:click=\"{() => navigate('relativePath')}\">\n    go to /route1/relativePath\n  </button>\n  <button on:click=\"{() => navigate('/absolutePath')}\">\n    go to /absolutePath\n  </button>\n  ```\n  *\n  * @example\n  ```html\n  <!-- App.svelte -->\n  <script>\n    import { link, Route } from \"svelte-navigator\";\n    import RouteComponent from \"./RouteComponent.svelte\";\n  </script>\n\n  <Router basepath=\"/base\">\n    <Route path=\"route1\">\n      <RouteComponent />\n    </Route>\n    <!-- ... -->\n  </Router>\n\n  <!-- RouteComponent.svelte -->\n  <script>\n    import { useNavigate } from \"svelte-navigator\";\n\n    const navigate = useNavigate();\n  </script>\n\n  <button on:click=\"{() => navigate('relativePath')}\">\n    go to /base/route1/relativePath\n  </button>\n  <button on:click=\"{() => navigate('/absolutePath')}\">\n    go to /base/absolutePath\n  </button>\n  ```\n */\nexport function useNavigate() {\n\tusePreflightCheck(USE_NAVIGATE_ID);\n\tconst resolve = useResolve();\n\tconst { navigate } = useHistory();\n\t/**\n\t * Navigate to a new route.\n\t * Resolves the link relative to the current route and basepath.\n\t *\n\t * @param {string|number} to The path to navigate to.\n\t *\n\t * If `to` is a number we will navigate to the stack entry index + `to`\n\t * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)\n\t * @param {Object} options\n\t * @param {*} [options.state]\n\t * @param {boolean} [options.replace=false]\n\t */\n\tconst navigateRelative = (to, options) => {\n\t\t// If to is a number, we navigate to the target stack entry via `history.go`.\n\t\t// Otherwise resolve the link\n\t\tconst target = isNumber(to) ? to : resolve(to);\n\t\treturn navigate(target, options);\n\t};\n\treturn navigateRelative;\n}\n\n/**\n * Use Svelte Navigators matching without needing to use a Route.\n * Returns a readable store with the potential match,\n * that changes, when the location changes.\n *\n * The provided path will be resolved relatively,\n * as you're used to with all paths in Svelte Navigator\n *\n * @param {string} path The path, to match against.\n * It works just like a Route path\n * @returns {RouteMatchStore} The matched route.\n * Returns `null`, when nothing could be matched\n *\n * @example\n  ```html\n  <script>\n    import { useMatch } from \"svelte-navigator\";\n\n    const relativeMatch = useMatch(\"relative/path/:to/*somewhere\");\n    const absoluteMatch = useMatch(\"/absolute/path/:to/*somewhere\");\n\n    $: console.log($relativeMatch.params.to);\n    $: console.log($absoluteMatch.params.somewhere);\n  </script>\n  ```\n */\nexport function useMatch(path) {\n\tusePreflightCheck(USE_MATCH_ID);\n\tconst location = useLocation();\n\tconst resolve = useResolve();\n\tconst { basepath: appBase } = getContext(ROUTER);\n\tconst resolvedPath = resolve(path);\n\tconst { pathname: fullPath } = normalizeLocation(\n\t\t{ pathname: resolvedPath },\n\t\tappBase,\n\t);\n\treturn derived(location, loc => match({ fullPath, path }, loc.pathname));\n}\n\n/**\n * Access the parent Routes matched params and wildcards\n * @returns {import(\"svelte/store\").Readable<{\n     [param: string]: any;\n   }>} A readable store containing the matched parameters and wildcards\n *\n * @example\n  ```html\n  <!--\n    Somewhere inside <Route path=\"user/:id/*splat\" />\n    with a current url of \"/myApp/user/123/pauls-profile\"\n  -->\n  <script>\n    import { useParams } from \"svelte-navigator\";\n\n    const params = useParams();\n\n    $: console.log($params); // -> { id: \"123\", splat: \"pauls-profile\" }\n  </script>\n\n  <h3>Welcome user {$params.id}! bleep bloop...</h3>\n  ```\n */\nexport function useParams() {\n\tusePreflightCheck(USE_PARAMS_ID, null, ROUTE, ROUTE_ID);\n\treturn toReadonly(ROUTE_PARAMS);\n}\n\n/**\n * Provide a custom element to focus, when the parent route is visited.\n * It returns the `registerFocus` function you can call manually with an\n * Element or use as a Svelte action via the `use` directive.\n *\n * @example\n  ```html\n  <!-- Using `registerFocus` as a Svelte action: -->\n  <!-- Somewhere inside a Route -->\n  <script>\n    import { useFocus } from \"svelte-navigator\";\n\n    const registerFocus = useFocus();\n  </script>\n\n  <h1>Don't worry about me...</h1>\n  <p use:registerFocus>Here, look at me!</p>\n  ```\n  * @example\n  ```html\n  <!-- Calling `registerFocus` manually: -->\n  <!-- Somewhere inside a Route -->\n  <script>\n    import { onMount } from \"svelte\";\n    import { useFocus } from \"svelte-navigator\";\n\n    const registerFocus = useFocus();\n\n    let focusElement;\n\n    onMount(() => registerFocus(focusElement))\n  </script>\n\n  <h1>Don't worry about me...</h1>\n  <p bind:this={focusElement}>Here, look at me!</p>\n  ```\n  * @example\n  ```html\n  <!-- Using `registerFocus` asyncronously: -->\n  <!-- Somewhere inside a Route -->\n  <script>\n    import { onMount } from \"svelte\";\n    import { useFocus } from \"svelte-navigator\";\n\n    const registerFocus = useFocus();\n\n    const lazyImport = import(\"./MyComponent.svelte\").then(module => module.default);\n  </script>\n\n  {#await lazyImport then MyComponent}\n    <MyComponent {registerFocus} />\n  {/await}\n\n  <!-- MyComponent.svelte -->\n  <script>\n    export let registerFocus;\n  </script>\n\n  <h1 use:registerFocus>Hi there!</h1>\n  ```\n */\nexport function useFocus() {\n\tusePreflightCheck(USE_FOCUS_ID, null, ROUTE, ROUTE_ID);\n\tconst location = useLocation();\n\tconst focusElement = getContext(FOCUS_ELEM);\n\n\tlet resolve;\n\tconst unsubscribe = location.subscribe(() => {\n\t\tconst lazyElement = new Promise(_resolve => {\n\t\t\tresolve = _resolve;\n\t\t});\n\t\tfocusElement.set(lazyElement);\n\t});\n\n\tonDestroy(unsubscribe);\n\n\treturn node => {\n\t\tlet unmounted = false;\n\t\tconst innerUnsubscribe = location.subscribe(() => {\n\t\t\ttick().then(() => {\n\t\t\t\tif (!unmounted) {\n\t\t\t\t\tresolve(node);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\tunmounted = true;\n\t\t\t\tinnerUnsubscribe();\n\t\t\t},\n\t\t};\n\t};\n}\n", "<script context=\"module\">\n\t// eslint-disable-next-line import/order\n\timport { createCounter, createMarkerProps } from \"./utils\";\n\n\tconst createId = createCounter();\n</script>\n\n<script>\n\t/*\n\t * Adapted from https://github.com/EmilTholin/svelte-routing\n\t *\n\t * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n\t */\n\n\timport { getContext, onDestroy, setContext } from \"svelte\";\n\timport { writable, get } from \"svelte/store\";\n\timport Router from \"./Router.svelte\";\n\timport { ROUTER, ROUTE, ROUTE_PARAMS, FOCUS_ELEM } from \"./contexts\";\n\timport {\n\t\tuseLocation,\n\t\tuseNavigate,\n\t\tuseRouteBase,\n\t\tusePreflightCheck,\n\t} from \"./hooks\";\n\timport { isSSR } from \"./utils\";\n\timport { extractBaseUri } from \"./routes\";\n\timport { join } from \"./paths\";\n\timport { ROUTE_ID } from \"./warning\";\n\n\texport let path = \"\";\n\texport let component = null;\n\texport let meta = {};\n\texport let primary = true;\n\n\tusePreflightCheck(ROUTE_ID, $$props);\n\n\tconst id = createId();\n\n\tconst { registerRoute, unregisterRoute, activeRoute, disableInlineStyles } =\n\t\tgetContext(ROUTER);\n\tconst parentBase = useRouteBase();\n\tconst location = useLocation();\n\tconst focusElement = writable(null);\n\n\t// In SSR we cannot wait for $activeRoute to update,\n\t// so we use the match returned from `registerRoute` instead\n\tlet ssrMatch;\n\n\tconst route = writable();\n\t$: {\n\t\t// The route store will be re-computed whenever props, location or parentBase change\n\t\tconst isDefault = path === \"\";\n\t\tconst rawBase = join($parentBase, path);\n\t\tconst updatedRoute = {\n\t\t\tid,\n\t\t\tpath,\n\t\t\tmeta,\n\t\t\t// If no path prop is given, this Route will act as the default Route\n\t\t\t// that is rendered if no other Route in the Router is a match\n\t\t\tdefault: isDefault,\n\t\t\tfullPath: isDefault ? \"\" : rawBase,\n\t\t\tbase: isDefault\n\t\t\t\t? $parentBase\n\t\t\t\t: extractBaseUri(rawBase, $location.pathname),\n\t\t\tprimary,\n\t\t\tfocusElement,\n\t\t};\n\t\troute.set(updatedRoute);\n\t\t// If we're in SSR mode and the Route matches,\n\t\t// `registerRoute` will return the match\n\t\tssrMatch = registerRoute(updatedRoute);\n\t}\n\n\t$: isActive = !!(ssrMatch || ($activeRoute && $activeRoute.id === id));\n\n\tconst params = writable({});\n\t$: if (isActive) {\n\t\tconst { params: activeParams } = ssrMatch || $activeRoute;\n\t\tparams.set(activeParams);\n\t}\n\n\tsetContext(ROUTE, route);\n\tsetContext(ROUTE_PARAMS, params);\n\tsetContext(FOCUS_ELEM, focusElement);\n\n\t// We need to call useNavigate after the route is set,\n\t// so we can use the routes path for link resolution\n\tconst navigate = useNavigate();\n\n\t// There is no need to unregister Routes in SSR since it will all be\n\t// thrown away anyway\n\tif (!isSSR) {\n\t\tonDestroy(() => unregisterRoute(id));\n\t}\n</script>\n\n<div {...createMarkerProps(disableInlineStyles)} data-svnav-route-start={id} />\n{#if isActive}\n\t<Router {primary}>\n\t\t<!--\n      `$params` always returns `{}` in SSR in Route, because it will\n      update after component initialisation has already happend.\n      `get(params)` always works, but is not reactive, so we can't\n      use it in client rendered mode\n    -->\n\t\t{#if component !== null}\n\t\t\t<svelte:component\n\t\t\t\tthis={component}\n\t\t\t\tlocation={$location}\n\t\t\t\t{navigate}\n\t\t\t\t{...isSSR ? get(params) : $params}\n\t\t\t\t{...$$restProps}\n\t\t\t/>\n\t\t{:else}\n\t\t\t<slot\n\t\t\t\tparams={isSSR ? get(params) : $params}\n\t\t\t\tlocation={$location}\n\t\t\t\t{navigate}\n\t\t\t/>\n\t\t{/if}\n\t</Router>\n{/if}\n<div {...createMarkerProps(disableInlineStyles)} data-svnav-route-end={id} />\n", "<script>\n\t/*\n\t * Adapted from https://github.com/EmilTholin/svelte-routing\n\t *\n\t * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n\t */\n\n\timport { createEventDispatcher } from \"svelte\";\n\timport {\n\t\tuseLocation,\n\t\tuseResolve,\n\t\tuseHistory,\n\t\tusePreflightCheck,\n\t} from \"./hooks\";\n\timport { shouldNavigate, isFunction } from \"./utils\";\n\timport { startsWith } from \"./paths\";\n\timport { LINK_ID } from \"./warning\";\n\timport { parsePath, stringifyPath } from \"./routes\";\n\n\texport let to;\n\texport let replace = false;\n\texport let state = {};\n\texport let getProps = null;\n\n\tusePreflightCheck(LINK_ID, $$props);\n\n\tconst location = useLocation();\n\tconst dispatch = createEventDispatcher();\n\tconst resolve = useResolve();\n\tconst { navigate } = useHistory();\n\n\t// We need to pass location here to force re-resolution of the link,\n\t// when the pathname changes. Otherwise we could end up with stale path params,\n\t// when for example an :id changes in the parent Routes path\n\t$: href = resolve(to, $location);\n\t$: isPartiallyCurrent = startsWith($location.pathname, href);\n\t$: isCurrent = href === $location.pathname;\n\t$: isExactCurrent = parsePath(href) === stringifyPath($location);\n\t$: ariaCurrent = isCurrent ? { \"aria-current\": \"page\" } : {};\n\t$: props = (() => {\n\t\tif (isFunction(getProps)) {\n\t\t\tconst dynamicProps = getProps({\n\t\t\t\tlocation: $location,\n\t\t\t\thref,\n\t\t\t\tisPartiallyCurrent,\n\t\t\t\tisCurrent,\n\t\t\t});\n\t\t\treturn { ...$$restProps, ...dynamicProps };\n\t\t}\n\t\treturn $$restProps;\n\t})();\n\n\tfunction onClick(event) {\n\t\tdispatch(\"click\", event);\n\n\t\tif (shouldNavigate(event)) {\n\t\t\tevent.preventDefault();\n\t\t\t// Don't push another entry to the history stack when the user\n\t\t\t// clicks on a Link to the page they are currently on.\n\t\t\tconst shouldReplace = isExactCurrent || replace;\n\t\t\tnavigate(href, { state, replace: shouldReplace });\n\t\t}\n\t}\n</script>\n\n<a {href} {...ariaCurrent} on:click={onClick} {...props}>\n\t<slot />\n</a>\n", "/*\n * Adapted from https://github.com/EmilTholin/svelte-routing\n *\n * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n */\n\nimport { navigate as defaultNavigate } from \"./history\";\nimport { shouldNavigate, findClosest, addListener, isFunction } from \"./utils\";\n\nconst createAction =\n\tgetAnchor =>\n\t(node, navigate = defaultNavigate) => {\n\t\tconst handleClick = event => {\n\t\t\tconst anchor = getAnchor(event);\n\t\t\tif (anchor && anchor.target === \"\" && shouldNavigate(event)) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst to = anchor.pathname + anchor.search + anchor.hash;\n\t\t\t\tnavigate(to, { replace: anchor.hasAttribute(\"replace\") });\n\t\t\t}\n\t\t};\n\t\tconst unlisten = addListener(node, \"click\", handleClick);\n\t\treturn { destroy: unlisten };\n\t};\n\n// prettier-ignore\n/**\n * A link action that can be added to <a href=\"\"> tags rather\n * than using the <Link> component.\n *\n * Example:\n * ```html\n * <a href=\"/post/{postId}\" use:link>{post.title}</a>\n * ```\n */\nexport const link = /*#__PURE__*/createAction(event => event.currentTarget); // eslint-disable-line spaced-comment, max-len\n\n// prettier-ignore\n/**\n * An action to be added at a root element of your application to\n * capture all relative links and push them onto the history stack.\n *\n * Example:\n * ```html\n * <div use:links>\n *   <Router>\n *     <Route path=\"/\" component={Home} />\n *     <Route path=\"/p/:projectId/:docId\" component={ProjectScreen} />\n *     {#each projects as project}\n *       <a href=\"/p/{project.id}\">{project.title}</a>\n *     {/each}\n *   </Router>\n * </div>\n * ```\n */\nexport const links = /*#__PURE__*/createAction(event => { // eslint-disable-line spaced-comment\n  const anchor = findClosest(\"A\", event.target);\n  if (\n    anchor &&\n    isFunction(anchor.hasAttribute) &&\n    !anchor.hasAttribute(\"noroute\")\n  ) {\n    return anchor;\n  }\n  return null;\n});\n"],
  "mappings": "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",
  "names": ["element", "query", "uri", "ctx", "resolve", "navigate", "ctx", "create_if_block", "createId", "navigate", "ctx", "resolve", "navigate", "navigate"]
}
