{
  "version": 3,
  "sources": ["../../svelte-navigator/src/utils.js", "../../svelte-navigator/src/contexts.js", "../../svelte-navigator/src/paths.js", "../../svelte-navigator/src/warning.js", "../../svelte-navigator/src/routes.js", "../../svelte-navigator/src/history.js", "../../svelte-navigator/src/a11y.js", "../../svelte-navigator/src/Router.svelte", "../../svelte-navigator/src/hooks.js", "../../svelte-navigator/src/Route.svelte", "../../svelte-navigator/src/Link.svelte", "../../svelte-navigator/src/actions.js"],
  "sourcesContent": ["/*\r\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js\r\n *\r\n * https://github.com/reach/router/blob/master/LICENSE\r\n */\r\n\r\nexport const isUndefined = value => typeof value === \"undefined\";\r\n\r\nexport const isFunction = value => typeof value === \"function\";\r\n\r\nexport const isNumber = value => typeof value === \"number\";\r\n\r\n/**\r\n * Decides whether a given `event` should result in a navigation or not.\r\n * @param {object} event\r\n */\r\nexport function shouldNavigate(event) {\r\n\treturn (\r\n\t\t!event.defaultPrevented &&\r\n\t\tevent.button === 0 &&\r\n\t\t!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\r\n\t);\r\n}\r\n\r\nexport function createCounter() {\r\n\tlet i = 0;\r\n\t/**\r\n\t * Returns an id and increments the internal state\r\n\t * @returns {number}\r\n\t */\r\n\treturn () => i++;\r\n}\r\n\r\n/**\r\n * Create a globally unique id\r\n *\r\n * @returns {string} An id\r\n */\r\nexport function createGlobalId() {\r\n\treturn Math.random().toString(36).substring(2);\r\n}\r\n\r\nexport function findClosest(tagName, element) {\r\n\twhile (element && element.tagName !== tagName) {\r\n\t\t// eslint-disable-next-line no-param-reassign\r\n\t\telement = element.parentNode;\r\n\t}\r\n\treturn element;\r\n}\r\n\r\nexport const isSSR = typeof window === \"undefined\";\r\n\r\nexport function addListener(target, type, handler) {\r\n\ttarget.addEventListener(type, handler);\r\n\treturn () => target.removeEventListener(type, handler);\r\n}\r\n\r\nexport const createInlineStyle = (disableInlineStyles, style) =>\r\n\tdisableInlineStyles ? {} : { style };\r\nexport const createMarkerProps = disableInlineStyles => ({\r\n\t\"aria-hidden\": \"true\",\r\n\t...createInlineStyle(disableInlineStyles, \"display:none;\"),\r\n});\r\n", "/*\r\n * Adapted from https://github.com/EmilTholin/svelte-routing\r\n *\r\n * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\r\n */\r\n\r\nconst createKey = ctxName => `@@svnav-ctx__${ctxName}`;\r\n\r\n// Use strings instead of objects, so different versions of\r\n// svelte-navigator can potentially still work together\r\nexport const LOCATION = createKey(\"LOCATION\");\r\nexport const ROUTER = createKey(\"ROUTER\");\r\nexport const ROUTE = createKey(\"ROUTE\");\r\nexport const ROUTE_PARAMS = createKey(\"ROUTE_PARAMS\");\r\nexport const FOCUS_ELEM = createKey(\"FOCUS_ELEM\");\r\n", "export const paramRegex = /^:(.+)/;\r\n\r\nexport const substr = (str, start, end) => str.substr(start, end);\r\n\r\n/**\r\n * Check if `string` starts with `search`\r\n * @param {string} string\r\n * @param {string} search\r\n * @return {boolean}\r\n */\r\nexport const startsWith = (string, search) =>\r\n\tsubstr(string, 0, search.length) === search;\r\n\r\n/**\r\n * Check if `segment` is a root segment\r\n * @param {string} segment\r\n * @return {boolean}\r\n */\r\nexport const isRootSegment = segment => segment === \"\";\r\n\r\n/**\r\n * Check if `segment` is a dynamic segment\r\n * @param {string} segment\r\n * @return {boolean}\r\n */\r\nexport const isDynamic = segment => paramRegex.test(segment);\r\n\r\n/**\r\n * Check if `segment` is a splat\r\n * @param {string} segment\r\n * @return {boolean}\r\n */\r\nexport const isSplat = segment => segment[0] === \"*\";\r\n\r\n/**\r\n * Strip potention splat and splatname of the end of a path\r\n * @param {string} str\r\n * @return {string}\r\n */\r\nexport const stripSplat = str => str.replace(/\\*.*$/, \"\");\r\n\r\n/**\r\n * Strip `str` of potential start and end `/`\r\n * @param {string} str\r\n * @return {string}\r\n */\r\nexport const stripSlashes = str => str.replace(/(^\\/+|\\/+$)/g, \"\");\r\n\r\n/**\r\n * Split up the URI into segments delimited by `/`\r\n * @param {string} uri\r\n * @return {string[]}\r\n */\r\nexport function segmentize(uri, filterFalsy = false) {\r\n\tconst segments = stripSlashes(uri).split(\"/\");\r\n\treturn filterFalsy ? segments.filter(Boolean) : segments;\r\n}\r\n\r\n/**\r\n * Add the query to the pathname if a query is given\r\n * @param {string} pathname\r\n * @param {string} [query]\r\n * @return {string}\r\n */\r\nexport const addQuery = (pathname, query) =>\r\n\tpathname + (query ? `?${query}` : \"\");\r\n\r\n/**\r\n * Combines the `basepath` and the `path` into one path.\r\n * @param {string} basepath\r\n * @param {string} path\r\n */\r\nexport function combinePaths(basepath, path) {\r\n\tconst barePath =\r\n\t\tpath === \"/\" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`;\r\n\treturn `${stripSlashes(barePath)}/`;\r\n}\r\n\r\n/**\r\n * Normalizes a basepath\r\n *\r\n * @param {string} path\r\n * @returns {string}\r\n *\r\n * @example\r\n * normalizePath(\"base/path/\") // -> \"/base/path\"\r\n */\r\nexport const normalizePath = path => `/${stripSlashes(path)}`;\r\n\r\n/**\r\n * Joins and normalizes multiple path fragments\r\n *\r\n * @param {...string} pathFragments\r\n * @returns {string}\r\n */\r\nexport function join(...pathFragments) {\r\n\tconst joinFragment = fragment => segmentize(fragment, true).join(\"/\");\r\n\tconst joinedSegments = pathFragments.map(joinFragment).join(\"/\");\r\n\treturn normalizePath(joinedSegments);\r\n}\r\n", "import { isFunction } from \"./utils\";\r\n\r\n// We start from 1 here, so we can check if an origin id has been passed\r\n// by using `originId || <fallback>`\r\nexport const LINK_ID = 1;\r\nexport const ROUTE_ID = 2;\r\nexport const ROUTER_ID = 3;\r\nexport const USE_FOCUS_ID = 4;\r\nexport const USE_LOCATION_ID = 5;\r\nexport const USE_MATCH_ID = 6;\r\nexport const USE_NAVIGATE_ID = 7;\r\nexport const USE_PARAMS_ID = 8;\r\nexport const USE_RESOLVABLE_ID = 9;\r\nexport const USE_RESOLVE_ID = 10;\r\nexport const NAVIGATE_ID = 11;\r\n\r\nconst labels = {\r\n\t[LINK_ID]: \"Link\",\r\n\t[ROUTE_ID]: \"Route\",\r\n\t[ROUTER_ID]: \"Router\",\r\n\t[USE_FOCUS_ID]: \"useFocus\",\r\n\t[USE_LOCATION_ID]: \"useLocation\",\r\n\t[USE_MATCH_ID]: \"useMatch\",\r\n\t[USE_NAVIGATE_ID]: \"useNavigate\",\r\n\t[USE_PARAMS_ID]: \"useParams\",\r\n\t[USE_RESOLVABLE_ID]: \"useResolvable\",\r\n\t[USE_RESOLVE_ID]: \"useResolve\",\r\n\t[NAVIGATE_ID]: \"navigate\",\r\n};\r\n\r\nexport const createLabel = labelId => labels[labelId];\r\n\r\nexport function createIdentifier(labelId, props) {\r\n\tlet attr;\r\n\tif (labelId === ROUTE_ID) {\r\n\t\tattr = props.path ? `path=\"${props.path}\"` : \"default\";\r\n\t} else if (labelId === LINK_ID) {\r\n\t\tattr = `to=\"${props.to}\"`;\r\n\t} else if (labelId === ROUTER_ID) {\r\n\t\tattr = `basepath=\"${props.basepath || \"\"}\"`;\r\n\t}\r\n\treturn `<${createLabel(labelId)} ${attr || \"\"} />`;\r\n}\r\n\r\nexport function createMessage(labelId, message, props, originId) {\r\n\tconst origin = props && createIdentifier(originId || labelId, props);\r\n\tconst originMsg = origin ? `\\n\\nOccurred in: ${origin}` : \"\";\r\n\tconst label = createLabel(labelId);\r\n\tconst msg = isFunction(message) ? message(label) : message;\r\n\treturn `<${label}> ${msg}${originMsg}`;\r\n}\r\n\r\nexport const createMessageHandler =\r\n\thandler =>\r\n\t(...args) =>\r\n\t\thandler(createMessage(...args));\r\n\r\nexport const fail = createMessageHandler(message => {\r\n\tthrow new Error(message);\r\n});\r\n\r\n// eslint-disable-next-line no-console\r\nexport const warn = createMessageHandler(console.warn);\r\n", "import {\r\n\tsegmentize,\r\n\tjoin,\r\n\taddQuery,\r\n\tstartsWith,\r\n\tparamRegex,\r\n\tisSplat,\r\n\tisRootSegment,\r\n\tisDynamic,\r\n\tstripSplat,\r\n\tnormalizePath,\r\n\tsubstr,\r\n} from \"./paths\";\r\nimport { ROUTER_ID, fail } from \"./warning\";\r\nimport { isUndefined } from \"./utils\";\r\n\r\nconst SEGMENT_POINTS = 4;\r\nconst STATIC_POINTS = 3;\r\nconst DYNAMIC_POINTS = 2;\r\nconst SPLAT_PENALTY = 1;\r\nconst ROOT_POINTS = 1;\r\n\r\n/**\r\n * Score a route depending on how its individual segments look\r\n * @param {object} route\r\n * @param {number} index\r\n * @return {object}\r\n */\r\nexport function rankRoute(route, index) {\r\n\tconst score = route.default\r\n\t\t? 0\r\n\t\t: segmentize(route.fullPath).reduce((acc, segment) => {\r\n\t\t\t\tlet nextScore = acc;\r\n\t\t\t\tnextScore += SEGMENT_POINTS;\r\n\r\n\t\t\t\tif (isRootSegment(segment)) {\r\n\t\t\t\t\tnextScore += ROOT_POINTS;\r\n\t\t\t\t} else if (isDynamic(segment)) {\r\n\t\t\t\t\tnextScore += DYNAMIC_POINTS;\r\n\t\t\t\t} else if (isSplat(segment)) {\r\n\t\t\t\t\tnextScore -= SEGMENT_POINTS + SPLAT_PENALTY;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnextScore += STATIC_POINTS;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn nextScore;\r\n\t\t  }, 0);\r\n\r\n\treturn { route, score, index };\r\n}\r\n\r\n/**\r\n * Give a score to all routes and sort them on that\r\n * @param {object[]} routes\r\n * @return {object[]}\r\n */\r\nexport function rankRoutes(routes) {\r\n\treturn (\r\n\t\troutes\r\n\t\t\t.map(rankRoute)\r\n\t\t\t// If two routes have the exact same score, we go by index instead\r\n\t\t\t.sort((a, b) => {\r\n\t\t\t\tif (a.score < b.score) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\t\t\t\tif (a.score > b.score) {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t\treturn a.index - b.index;\r\n\t\t\t})\r\n\t);\r\n}\r\n\r\n/**\r\n * Ranks and picks the best route to match. Each segment gets the highest\r\n * amount of points, then the type of segment gets an additional amount of\r\n * points where\r\n *\r\n *  static > dynamic > splat > root\r\n *\r\n * This way we don't have to worry about the order of our routes, let the\r\n * computers do it.\r\n *\r\n * A route looks like this\r\n *\r\n *  { fullPath, default, value }\r\n *\r\n * And a returned match looks like:\r\n *\r\n *  { route, params, uri }\r\n *\r\n * @param {object[]} routes\r\n * @param {string} uri\r\n * @return {?object}\r\n */\r\nexport function pick(routes, uri) {\r\n\tlet bestMatch;\r\n\tlet defaultMatch;\r\n\r\n\tconst [uriPathname] = uri.split(\"?\");\r\n\tconst uriSegments = segmentize(uriPathname);\r\n\tconst isRootUri = uriSegments[0] === \"\";\r\n\tconst ranked = rankRoutes(routes);\r\n\r\n\tfor (let i = 0, l = ranked.length; i < l; i++) {\r\n\t\tconst { route } = ranked[i];\r\n\t\tlet missed = false;\r\n\t\tconst params = {};\r\n\r\n\t\t// eslint-disable-next-line no-shadow\r\n\t\tconst createMatch = uri => ({ ...route, params, uri });\r\n\r\n\t\tif (route.default) {\r\n\t\t\tdefaultMatch = createMatch(uri);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tconst routeSegments = segmentize(route.fullPath);\r\n\t\tconst max = Math.max(uriSegments.length, routeSegments.length);\r\n\t\tlet index = 0;\r\n\r\n\t\tfor (; index < max; index++) {\r\n\t\t\tconst routeSegment = routeSegments[index];\r\n\t\t\tconst uriSegment = uriSegments[index];\r\n\r\n\t\t\tif (!isUndefined(routeSegment) && isSplat(routeSegment)) {\r\n\t\t\t\t// Hit a splat, just grab the rest, and return a match\r\n\t\t\t\t// uri:   /files/documents/work\r\n\t\t\t\t// route: /files/* or /files/*splatname\r\n\t\t\t\tconst splatName = routeSegment === \"*\" ? \"*\" : routeSegment.slice(1);\r\n\r\n\t\t\t\tparams[splatName] = uriSegments\r\n\t\t\t\t\t.slice(index)\r\n\t\t\t\t\t.map(decodeURIComponent)\r\n\t\t\t\t\t.join(\"/\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (isUndefined(uriSegment)) {\r\n\t\t\t\t// URI is shorter than the route, no match\r\n\t\t\t\t// uri:   /users\r\n\t\t\t\t// route: /users/:userId\r\n\t\t\t\tmissed = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tconst dynamicMatch = paramRegex.exec(routeSegment);\r\n\r\n\t\t\tif (dynamicMatch && !isRootUri) {\r\n\t\t\t\tconst value = decodeURIComponent(uriSegment);\r\n\t\t\t\tparams[dynamicMatch[1]] = value;\r\n\t\t\t} else if (routeSegment !== uriSegment) {\r\n\t\t\t\t// Current segments don't match, not dynamic, not splat, so no match\r\n\t\t\t\t// uri:   /users/123/settings\r\n\t\t\t\t// route: /users/:id/profile\r\n\t\t\t\tmissed = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!missed) {\r\n\t\t\tbestMatch = createMatch(join(...uriSegments.slice(0, index)));\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn bestMatch || defaultMatch || null;\r\n}\r\n\r\n/**\r\n * Check if the `route.fullPath` matches the `uri`.\r\n * @param {Object} route\r\n * @param {string} uri\r\n * @return {?object}\r\n */\r\nexport function match(route, uri) {\r\n\treturn pick([route], uri);\r\n}\r\n\r\n/**\r\n * Resolve URIs as though every path is a directory, no files. Relative URIs\r\n * in the browser can feel awkward because not only can you be \"in a directory\",\r\n * you can be \"at a file\", too. For example:\r\n *\r\n *  browserSpecResolve('foo', '/bar/') => /bar/foo\r\n *  browserSpecResolve('foo', '/bar') => /foo\r\n *\r\n * But on the command line of a file system, it's not as complicated. You can't\r\n * `cd` from a file, only directories. This way, links have to know less about\r\n * their current path. To go deeper you can do this:\r\n *\r\n *  <Link to=\"deeper\"/>\r\n *  // instead of\r\n *  <Link to=`{${props.uri}/deeper}`/>\r\n *\r\n * Just like `cd`, if you want to go deeper from the command line, you do this:\r\n *\r\n *  cd deeper\r\n *  # not\r\n *  cd $(pwd)/deeper\r\n *\r\n * By treating every path as a directory, linking to relative paths should\r\n * require less contextual information and (fingers crossed) be more intuitive.\r\n * @param {string} to\r\n * @param {string} base\r\n * @return {string}\r\n */\r\nexport function resolve(to, base) {\r\n\t// /foo/bar, /baz/qux => /foo/bar\r\n\tif (startsWith(to, \"/\")) {\r\n\t\treturn to;\r\n\t}\r\n\r\n\tconst [toPathname, toQuery] = to.split(\"?\");\r\n\tconst [basePathname] = base.split(\"?\");\r\n\tconst toSegments = segmentize(toPathname);\r\n\tconst baseSegments = segmentize(basePathname);\r\n\r\n\t// ?a=b, /users?b=c => /users?a=b\r\n\tif (toSegments[0] === \"\") {\r\n\t\treturn addQuery(basePathname, toQuery);\r\n\t}\r\n\r\n\t// profile, /users/789 => /users/789/profile\r\n\tif (!startsWith(toSegments[0], \".\")) {\r\n\t\tconst pathname = baseSegments.concat(toSegments).join(\"/\");\r\n\t\treturn addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\r\n\t}\r\n\r\n\t// ./       , /users/123 => /users/123\r\n\t// ../      , /users/123 => /users\r\n\t// ../..    , /users/123 => /\r\n\t// ../../one, /a/b/c/d   => /a/b/one\r\n\t// .././one , /a/b/c/d   => /a/b/c/one\r\n\tconst allSegments = baseSegments.concat(toSegments);\r\n\tconst segments = [];\r\n\r\n\tallSegments.forEach(segment => {\r\n\t\tif (segment === \"..\") {\r\n\t\t\tsegments.pop();\r\n\t\t} else if (segment !== \".\") {\r\n\t\t\tsegments.push(segment);\r\n\t\t}\r\n\t});\r\n\r\n\treturn addQuery(`/${segments.join(\"/\")}`, toQuery);\r\n}\r\n\r\n/**\r\n * Normalizes a location for consumption by `Route` children and the `Router`.\r\n * It removes the apps basepath from the pathname\r\n * and sets default values for `search` and `hash` properties.\r\n *\r\n * @param {Object} location The current global location supplied by the history component\r\n * @param {string} basepath The applications basepath (i.e. when serving from a subdirectory)\r\n *\r\n * @returns The normalized location\r\n */\r\nexport function normalizeLocation(location, basepath) {\r\n\tconst { pathname, hash = \"\", search = \"\", state } = location;\r\n\tconst baseSegments = segmentize(basepath, true);\r\n\tconst pathSegments = segmentize(pathname, true);\r\n\twhile (baseSegments.length) {\r\n\t\tif (baseSegments[0] !== pathSegments[0]) {\r\n\t\t\tfail(\r\n\t\t\t\tROUTER_ID,\r\n\t\t\t\t`Invalid state: All locations must begin with the basepath \"${basepath}\", found \"${pathname}\"`,\r\n\t\t\t);\r\n\t\t}\r\n\t\tbaseSegments.shift();\r\n\t\tpathSegments.shift();\r\n\t}\r\n\treturn {\r\n\t\tpathname: join(...pathSegments),\r\n\t\thash,\r\n\t\tsearch,\r\n\t\tstate,\r\n\t};\r\n}\r\n\r\nconst normalizeUrlFragment = frag => (frag.length === 1 ? \"\" : frag);\r\n\r\n/**\r\n * Creates a location object from an url.\r\n * It is used to create a location from the url prop used in SSR\r\n *\r\n * @param {string} url The url string (e.g. \"/path/to/somewhere\")\r\n * @returns {{ pathname: string; search: string; hash: string }} The location\r\n *\r\n * @example\r\n * ```js\r\n * const path = \"/search?q=falafel#result-3\";\r\n * const location = parsePath(path);\r\n * // -> {\r\n * //   pathname: \"/search\",\r\n * //   search: \"?q=falafel\",\r\n * //   hash: \"#result-3\",\r\n * // };\r\n * ```\r\n */\r\nexport const parsePath = path => {\r\n\tconst searchIndex = path.indexOf(\"?\");\r\n\tconst hashIndex = path.indexOf(\"#\");\r\n\tconst hasSearchIndex = searchIndex !== -1;\r\n\tconst hasHashIndex = hashIndex !== -1;\r\n\tconst hash = hasHashIndex\r\n\t\t? normalizeUrlFragment(substr(path, hashIndex))\r\n\t\t: \"\";\r\n\tconst pathnameAndSearch = hasHashIndex ? substr(path, 0, hashIndex) : path;\r\n\tconst search = hasSearchIndex\r\n\t\t? normalizeUrlFragment(substr(pathnameAndSearch, searchIndex))\r\n\t\t: \"\";\r\n\tconst pathname =\r\n\t\t(hasSearchIndex\r\n\t\t\t? substr(pathnameAndSearch, 0, searchIndex)\r\n\t\t\t: pathnameAndSearch) || \"/\";\r\n\treturn { pathname, search, hash };\r\n};\r\n\r\n/**\r\n * Joins a location object to one path string.\r\n *\r\n * @param {{ pathname: string; search: string; hash: string }} location The location object\r\n * @returns {string} A path, created from the location\r\n *\r\n * @example\r\n * ```js\r\n * const location = {\r\n *   pathname: \"/search\",\r\n *   search: \"?q=falafel\",\r\n *   hash: \"#result-3\",\r\n * };\r\n * const path = stringifyPath(location);\r\n * // -> \"/search?q=falafel#result-3\"\r\n * ```\r\n */\r\nexport const stringifyPath = location => {\r\n\tconst { pathname, search, hash } = location;\r\n\treturn pathname + search + hash;\r\n};\r\n\r\n/**\r\n * Resolves a link relative to the parent Route and the Routers basepath.\r\n *\r\n * @param {string} path The given path, that will be resolved\r\n * @param {string} routeBase The current Routes base path\r\n * @param {string} appBase The basepath of the app. Used, when serving from a subdirectory\r\n * @returns {string} The resolved path\r\n *\r\n * @example\r\n * resolveLink(\"relative\", \"/routeBase\", \"/\") // -> \"/routeBase/relative\"\r\n * resolveLink(\"/absolute\", \"/routeBase\", \"/\") // -> \"/absolute\"\r\n * resolveLink(\"relative\", \"/routeBase\", \"/base\") // -> \"/base/routeBase/relative\"\r\n * resolveLink(\"/absolute\", \"/routeBase\", \"/base\") // -> \"/base/absolute\"\r\n */\r\nexport function resolveLink(path, routeBase, appBase) {\r\n\treturn join(appBase, resolve(path, routeBase));\r\n}\r\n\r\n/**\r\n * Get the uri for a Route, by matching it against the current location.\r\n *\r\n * @param {string} routePath The Routes resolved path\r\n * @param {string} pathname The current locations pathname\r\n */\r\nexport function extractBaseUri(routePath, pathname) {\r\n\tconst fullPath = normalizePath(stripSplat(routePath));\r\n\tconst baseSegments = segmentize(fullPath, true);\r\n\tconst pathSegments = segmentize(pathname, true).slice(0, baseSegments.length);\r\n\tconst routeMatch = match({ fullPath }, join(...pathSegments));\r\n\treturn routeMatch && routeMatch.uri;\r\n}\r\n", "/*\r\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js\r\n *\r\n * https://github.com/reach/router/blob/master/LICENSE\r\n */\r\n\r\nimport { parsePath } from \"./routes\";\r\nimport { createGlobalId, isSSR, isNumber, addListener } from \"./utils\";\r\nimport { warn, NAVIGATE_ID } from \"./warning\";\r\n\r\nconst POP = \"POP\";\r\nconst PUSH = \"PUSH\";\r\nconst REPLACE = \"REPLACE\";\r\n\r\nfunction getLocation(source) {\r\n\treturn {\r\n\t\t...source.location,\r\n\t\tpathname: encodeURI(decodeURI(source.location.pathname)),\r\n\t\tstate: source.history.state,\r\n\t\t_key: (source.history.state && source.history.state._key) || \"initial\",\r\n\t};\r\n}\r\n\r\nfunction createHistory(source) {\r\n\tlet listeners = [];\r\n\tlet location = getLocation(source);\r\n\tlet action = POP;\r\n\r\n\tconst notifyListeners = (listenerFns = listeners) =>\r\n\t\tlistenerFns.forEach(listener => listener({ location, action }));\r\n\r\n\treturn {\r\n\t\tget location() {\r\n\t\t\treturn location;\r\n\t\t},\r\n\t\tlisten(listener) {\r\n\t\t\tlisteners.push(listener);\r\n\r\n\t\t\tconst popstateListener = () => {\r\n\t\t\t\tlocation = getLocation(source);\r\n\t\t\t\taction = POP;\r\n\t\t\t\tnotifyListeners([listener]);\r\n\t\t\t};\r\n\r\n\t\t\t// Call listener when it is registered\r\n\t\t\tnotifyListeners([listener]);\r\n\r\n\t\t\tconst unlisten = addListener(source, \"popstate\", popstateListener);\r\n\t\t\treturn () => {\r\n\t\t\t\tunlisten();\r\n\t\t\t\tlisteners = listeners.filter(fn => fn !== listener);\r\n\t\t\t};\r\n\t\t},\r\n\t\t/**\r\n\t\t * Navigate to a new absolute route.\r\n\t\t *\r\n\t\t * @param {string|number} to The path to navigate to.\r\n\t\t *\r\n\t\t * If `to` is a number we will navigate to the stack entry index + `to`\r\n\t\t * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)\r\n\t\t * @param {Object} options\r\n\t\t * @param {*} [options.state] The state will be accessible through `location.state`\r\n\t\t * @param {boolean} [options.replace=false] Replace the current entry in the history\r\n\t\t * stack, instead of pushing on a new one\r\n\t\t */\r\n\t\tnavigate(to, options) {\r\n\t\t\tconst { state = {}, replace = false } = options || {};\r\n\t\t\taction = replace ? REPLACE : PUSH;\r\n\t\t\tif (isNumber(to)) {\r\n\t\t\t\tif (options) {\r\n\t\t\t\t\twarn(\r\n\t\t\t\t\t\tNAVIGATE_ID,\r\n\t\t\t\t\t\t\"Navigation options (state or replace) are not supported, \" +\r\n\t\t\t\t\t\t\t\"when passing a number as the first argument to navigate. \" +\r\n\t\t\t\t\t\t\t\"They are ignored.\",\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\taction = POP;\r\n\t\t\t\tsource.history.go(to);\r\n\t\t\t} else {\r\n\t\t\t\tconst keyedState = { ...state, _key: createGlobalId() };\r\n\t\t\t\t// try...catch iOS Safari limits to 100 pushState calls\r\n\t\t\t\ttry {\r\n\t\t\t\t\tsource.history[replace ? \"replaceState\" : \"pushState\"](\r\n\t\t\t\t\t\tkeyedState,\r\n\t\t\t\t\t\t\"\",\r\n\t\t\t\t\t\tto,\r\n\t\t\t\t\t);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tsource.location[replace ? \"replace\" : \"assign\"](to);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlocation = getLocation(source);\r\n\t\t\tnotifyListeners();\r\n\t\t},\r\n\t};\r\n}\r\n\r\nfunction createStackFrame(state, uri) {\r\n\treturn { ...parsePath(uri), state };\r\n}\r\n\r\n// Stores history entries in memory for testing or other platforms like Native\r\nfunction createMemorySource(initialPathname = \"/\") {\r\n\tlet index = 0;\r\n\tlet stack = [createStackFrame(null, initialPathname)];\r\n\r\n\treturn {\r\n\t\t// This is just for testing...\r\n\t\tget entries() {\r\n\t\t\treturn stack;\r\n\t\t},\r\n\t\tget location() {\r\n\t\t\treturn stack[index];\r\n\t\t},\r\n\t\taddEventListener() {},\r\n\t\tremoveEventListener() {},\r\n\t\thistory: {\r\n\t\t\tget state() {\r\n\t\t\t\treturn stack[index].state;\r\n\t\t\t},\r\n\t\t\tpushState(state, title, uri) {\r\n\t\t\t\tindex++;\r\n\t\t\t\t// Throw away anything in the stack with an index greater than the current index.\r\n\t\t\t\t// This happens, when we go back using `go(-n)`. The index is now less than `stack.length`.\r\n\t\t\t\t// If we call `go(+n)` the stack entries with an index greater than the current index can\r\n\t\t\t\t// be reused.\r\n\t\t\t\t// However, if we navigate to a path, instead of a number, we want to create a new branch\r\n\t\t\t\t// of navigation.\r\n\t\t\t\tstack = stack.slice(0, index);\r\n\t\t\t\tstack.push(createStackFrame(state, uri));\r\n\t\t\t},\r\n\t\t\treplaceState(state, title, uri) {\r\n\t\t\t\tstack[index] = createStackFrame(state, uri);\r\n\t\t\t},\r\n\t\t\tgo(to) {\r\n\t\t\t\tconst newIndex = index + to;\r\n\t\t\t\tif (newIndex < 0 || newIndex > stack.length - 1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tindex = newIndex;\r\n\t\t\t},\r\n\t\t},\r\n\t};\r\n}\r\n\r\n// Global history uses window.history as the source if available,\r\n// otherwise a memory history\r\nconst canUseDOM = !!(\r\n\t!isSSR &&\r\n\twindow.document &&\r\n\twindow.document.createElement\r\n);\r\n// Use memory history in iframes (for example in Svelte REPL)\r\nconst isEmbeddedPage = !isSSR && window.location.origin === \"null\";\r\nconst globalHistory = createHistory(\r\n\tcanUseDOM && !isEmbeddedPage ? window : createMemorySource(),\r\n);\r\nconst { navigate } = globalHistory;\r\n\r\nexport { globalHistory, navigate, createHistory, createMemorySource };\r\n", "import { get } from \"svelte/store\";\r\nimport { tick } from \"svelte\";\r\nimport { warn, ROUTER_ID, ROUTE_ID } from \"./warning\";\r\nimport { addListener } from \"./utils\";\r\n\r\n// We need to keep the focus candidate in a separate file, so svelte does\r\n// not update, when we mutate it.\r\n// Also, we need a single global reference, because taking focus needs to\r\n// work globally, even if we have multiple top level routers\r\n// eslint-disable-next-line import/no-mutable-exports\r\nexport let focusCandidate = null;\r\n\r\n// eslint-disable-next-line import/no-mutable-exports\r\nexport let initialNavigation = true;\r\n\r\n/**\r\n * Check if RouterA is above RouterB in the document\r\n * @param {number} routerIdA The first Routers id\r\n * @param {number} routerIdB The second Routers id\r\n */\r\nfunction isAbove(routerIdA, routerIdB) {\r\n\tconst routerMarkers = document.querySelectorAll(\"[data-svnav-router]\");\r\n\tfor (let i = 0; i < routerMarkers.length; i++) {\r\n\t\tconst node = routerMarkers[i];\r\n\t\tconst currentId = Number(node.dataset.svnavRouter);\r\n\t\tif (currentId === routerIdA) return true;\r\n\t\tif (currentId === routerIdB) return false;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * Check if a Route candidate is the best choice to move focus to,\r\n * and store the best match.\r\n * @param {{\r\n     level: number;\r\n     routerId: number;\r\n     route: {\r\n       id: number;\r\n       focusElement: import(\"svelte/store\").Readable<Promise<Element>|null>;\r\n     }\r\n   }} item A Route candidate, that updated and is visible after a navigation\r\n */\r\nexport function pushFocusCandidate(item) {\r\n\tif (\r\n\t\t// Best candidate if it's the only candidate...\r\n\t\t!focusCandidate ||\r\n\t\t// Route is nested deeper, than previous candidate\r\n\t\t// -> Route change was triggered in the deepest affected\r\n\t\t// Route, so that's were focus should move to\r\n\t\titem.level > focusCandidate.level ||\r\n\t\t// If the level is identical, we want to focus the first Route in the document,\r\n\t\t// so we pick the first Router lookin from page top to page bottom.\r\n\t\t(item.level === focusCandidate.level &&\r\n\t\t\tisAbove(item.routerId, focusCandidate.routerId))\r\n\t) {\r\n\t\tfocusCandidate = item;\r\n\t}\r\n}\r\n\r\n/**\r\n * Reset the focus candidate.\r\n */\r\nexport function clearFocusCandidate() {\r\n\tfocusCandidate = null;\r\n}\r\n\r\nexport function initialNavigationOccurred() {\r\n\tinitialNavigation = false;\r\n}\r\n\r\n/*\r\n * `focus` Adapted from https://github.com/oaf-project/oaf-side-effects/blob/master/src/index.ts\r\n *\r\n * https://github.com/oaf-project/oaf-side-effects/blob/master/LICENSE\r\n */\r\nexport function focus(elem) {\r\n\tif (!elem) return false;\r\n\tconst TABINDEX = \"tabindex\";\r\n\ttry {\r\n\t\tif (!elem.hasAttribute(TABINDEX)) {\r\n\t\t\telem.setAttribute(TABINDEX, \"-1\");\r\n\t\t\tlet unlisten;\r\n\t\t\t// We remove tabindex after blur to avoid weird browser behavior\r\n\t\t\t// where a mouse click can activate elements with tabindex=\"-1\".\r\n\t\t\tconst blurListener = () => {\r\n\t\t\t\telem.removeAttribute(TABINDEX);\r\n\t\t\t\tunlisten();\r\n\t\t\t};\r\n\t\t\tunlisten = addListener(elem, \"blur\", blurListener);\r\n\t\t}\r\n\t\telem.focus();\r\n\t\treturn document.activeElement === elem;\r\n\t} catch (e) {\r\n\t\t// Apparently trying to focus a disabled element in IE can throw.\r\n\t\t// See https://stackoverflow.com/a/1600194/2476884\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nexport function isEndMarker(elem, id) {\r\n\treturn Number(elem.dataset.svnavRouteEnd) === id;\r\n}\r\n\r\nexport function isHeading(elem) {\r\n\treturn /^H[1-6]$/i.test(elem.tagName);\r\n}\r\n\r\nfunction query(selector, parent = document) {\r\n\treturn parent.querySelector(selector);\r\n}\r\n\r\nexport function queryHeading(id) {\r\n\tconst marker = query(`[data-svnav-route-start=\"${id}\"]`);\r\n\tlet current = marker.nextElementSibling;\r\n\twhile (!isEndMarker(current, id)) {\r\n\t\tif (isHeading(current)) {\r\n\t\t\treturn current;\r\n\t\t}\r\n\t\tconst heading = query(\"h1,h2,h3,h4,h5,h6\", current);\r\n\t\tif (heading) {\r\n\t\t\treturn heading;\r\n\t\t}\r\n\t\tcurrent = current.nextElementSibling;\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nexport function handleFocus(route) {\r\n\tPromise.resolve(get(route.focusElement)).then(elem => {\r\n\t\tconst focusElement = elem || queryHeading(route.id);\r\n\t\tif (!focusElement) {\r\n\t\t\twarn(\r\n\t\t\t\tROUTER_ID,\r\n\t\t\t\t\"Could not find an element to focus. \" +\r\n\t\t\t\t\t\"You should always render a header for accessibility reasons, \" +\r\n\t\t\t\t\t'or set a custom focus element via the \"useFocus\" hook. ' +\r\n\t\t\t\t\t\"If you don't want this Route or Router to manage focus, \" +\r\n\t\t\t\t\t'pass \"primary={false}\" to it.',\r\n\t\t\t\troute,\r\n\t\t\t\tROUTE_ID,\r\n\t\t\t);\r\n\t\t}\r\n\t\tconst headingFocused = focus(focusElement);\r\n\t\tif (headingFocused) return;\r\n\t\tfocus(document.documentElement);\r\n\t});\r\n}\r\n\r\nexport const createTriggerFocus =\r\n\t(a11yConfig, announcementText, location) =>\r\n\t(manageFocus, announceNavigation) =>\r\n\t\t// Wait until the dom is updated, so we can look for headings\r\n\t\ttick().then(() => {\r\n\t\t\tif (!focusCandidate || initialNavigation) {\r\n\t\t\t\tinitialNavigationOccurred();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (manageFocus) {\r\n\t\t\t\thandleFocus(focusCandidate.route);\r\n\t\t\t}\r\n\t\t\tif (a11yConfig.announcements && announceNavigation) {\r\n\t\t\t\tconst { path, fullPath, meta, params, uri } = focusCandidate.route;\r\n\t\t\t\tconst announcementMessage = a11yConfig.createAnnouncement(\r\n\t\t\t\t\t{ path, fullPath, meta, params, uri },\r\n\t\t\t\t\tget(location),\r\n\t\t\t\t);\r\n\t\t\t\tPromise.resolve(announcementMessage).then(message => {\r\n\t\t\t\t\tannouncementText.set(message);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tclearFocusCandidate();\r\n\t\t});\r\n\r\nexport const visuallyHiddenStyle =\r\n\t\"position:fixed;\" +\r\n\t\"top:-1px;\" +\r\n\t\"left:0;\" +\r\n\t\"width:1px;\" +\r\n\t\"height:1px;\" +\r\n\t\"padding:0;\" +\r\n\t\"overflow:hidden;\" +\r\n\t\"clip:rect(0,0,0,0);\" +\r\n\t\"white-space:nowrap;\" +\r\n\t\"border:0;\";\r\n", "<script context=\"module\">\r\n\t// eslint-disable-next-line import/order\r\n\timport { createCounter, createInlineStyle, createMarkerProps } from \"./utils\";\r\n\r\n\tconst createId = createCounter();\r\n</script>\r\n\r\n<script>\r\n\t/*\r\n\t * Adapted from https://github.com/EmilTholin/svelte-routing\r\n\t *\r\n\t * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\r\n\t */\r\n\r\n\timport { getContext, setContext, onMount } from \"svelte\";\r\n\timport { writable } from \"svelte/store\";\r\n\timport { LOCATION, ROUTER } from \"./contexts\";\r\n\timport { globalHistory } from \"./history\";\r\n\timport { normalizePath } from \"./paths\";\r\n\timport { pick, match, normalizeLocation, parsePath } from \"./routes\";\r\n\timport { isSSR } from \"./utils\";\r\n\timport { warn, ROUTER_ID } from \"./warning\";\r\n\timport {\r\n\t\tpushFocusCandidate,\r\n\t\tvisuallyHiddenStyle,\r\n\t\tcreateTriggerFocus,\r\n\t} from \"./a11y\";\r\n\r\n\tconst defaultBasepath = \"/\";\r\n\r\n\texport let basepath = defaultBasepath;\r\n\texport let url = null;\r\n\texport let history = globalHistory;\r\n\texport let primary = true;\r\n\texport let a11y = {};\r\n\texport let disableInlineStyles = false;\r\n\r\n\tconst a11yConfig = {\r\n\t\tcreateAnnouncement: route => `Navigated to ${route.uri}`,\r\n\t\tannouncements: true,\r\n\t\t...a11y,\r\n\t};\r\n\r\n\t// Remember the initial `basepath`, so we can fire a warning\r\n\t// when the user changes it later\r\n\tconst initialBasepath = basepath;\r\n\tconst normalizedBasepath = normalizePath(basepath);\r\n\r\n\tconst locationContext = getContext(LOCATION);\r\n\tconst routerContext = getContext(ROUTER);\r\n\r\n\tconst isTopLevelRouter = !locationContext;\r\n\tconst routerId = createId();\r\n\r\n\tconst manageFocus = primary && !(routerContext && !routerContext.manageFocus);\r\n\tconst announcementText = writable(\"\");\r\n\r\n\tconst shouldDisableInlineStyles = routerContext\r\n\t\t? routerContext.disableInlineStyles\r\n\t\t: disableInlineStyles;\r\n\r\n\tconst routes = writable([]);\r\n\tconst activeRoute = writable(null);\r\n\t// Used in SSR to synchronously set that a Route is active.\r\n\tlet hasActiveRoute = false;\r\n\r\n\t// Nesting level of router.\r\n\t// We will need this to identify sibling routers, when moving\r\n\t// focus on navigation, so we can focus the first possible router\r\n\tconst level = isTopLevelRouter ? 0 : routerContext.level + 1;\r\n\r\n\t// If we're running an SSR we force the location to the `url` prop\r\n\tconst getInitialLocation = () =>\r\n\t\tnormalizeLocation(\r\n\t\t\tisSSR ? parsePath(url) : history.location,\r\n\t\t\tnormalizedBasepath,\r\n\t\t);\r\n\tconst location = isTopLevelRouter\r\n\t\t? writable(getInitialLocation())\r\n\t\t: locationContext;\r\n\tconst prevLocation = writable($location);\r\n\r\n\tconst triggerFocus = createTriggerFocus(\r\n\t\ta11yConfig,\r\n\t\tannouncementText,\r\n\t\tlocation,\r\n\t);\r\n\r\n\tconst createRouteFilter = routeId => routeList =>\r\n\t\trouteList.filter(routeItem => routeItem.id !== routeId);\r\n\r\n\tfunction registerRoute(route) {\r\n\t\tif (isSSR) {\r\n\t\t\t// In SSR we should set the activeRoute immediately if it is a match.\r\n\t\t\t// If there are more Routes being registered after a match is found,\r\n\t\t\t// we just skip them.\r\n\t\t\tif (hasActiveRoute) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst matchingRoute = match(route, $location.pathname);\r\n\t\t\tif (matchingRoute) {\r\n\t\t\t\thasActiveRoute = true;\r\n\t\t\t\t// Return the match in SSR mode, so the matched Route can use it immediatly.\r\n\t\t\t\t// Waiting for activeRoute to update does not work, because it updates\r\n\t\t\t\t// after the Route is initialized\r\n\t\t\t\treturn matchingRoute; // eslint-disable-line consistent-return\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\troutes.update(prevRoutes => {\r\n\t\t\t\t// Remove an old version of the updated route,\r\n\t\t\t\t// before pushing the new version\r\n\t\t\t\tconst nextRoutes = createRouteFilter(route.id)(prevRoutes);\r\n\t\t\t\tnextRoutes.push(route);\r\n\t\t\t\treturn nextRoutes;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unregisterRoute(routeId) {\r\n\t\troutes.update(createRouteFilter(routeId));\r\n\t}\r\n\r\n\tif (!isTopLevelRouter && basepath !== defaultBasepath) {\r\n\t\twarn(\r\n\t\t\tROUTER_ID,\r\n\t\t\t'Only top-level Routers can have a \"basepath\" prop. It is ignored.',\r\n\t\t\t{ basepath },\r\n\t\t);\r\n\t}\r\n\t$: if (basepath !== initialBasepath) {\r\n\t\twarn(ROUTER_ID, 'You cannot change the \"basepath\" prop. It is ignored.');\r\n\t}\r\n\r\n\t// This reactive statement will be run when the Router is created\r\n\t// when there are no Routes and then again the following tick, so it\r\n\t// will not find an active Route in SSR and in the browser it will only\r\n\t// pick an active Route after all Routes have been registered.\r\n\t$: {\r\n\t\tconst bestMatch = pick($routes, $location.pathname);\r\n\t\tactiveRoute.set(bestMatch);\r\n\t}\r\n\r\n\t// Manage focus and announce navigation to screen reader users\r\n\t$: {\r\n\t\tif (isTopLevelRouter) {\r\n\t\t\tconst hasHash = !!$location.hash;\r\n\t\t\t// When a hash is present in the url, we skip focus management, because\r\n\t\t\t// focusing a different element will prevent in-page jumps (See #3)\r\n\t\t\tconst shouldManageFocus = !hasHash && manageFocus;\r\n\t\t\t// We don't want to make an announcement, when the hash changes,\r\n\t\t\t// but the active route stays the same\r\n\t\t\tconst announceNavigation =\r\n\t\t\t\t!hasHash || $location.pathname !== $prevLocation.pathname;\r\n\t\t\ttriggerFocus(shouldManageFocus, announceNavigation);\r\n\t\t}\r\n\t}\r\n\r\n\t// Queue matched Route, so top level Router can decide which Route to focus.\r\n\t// Non primary Routers should just be ignored\r\n\t$: if (manageFocus && $activeRoute && $activeRoute.primary) {\r\n\t\tpushFocusCandidate({ level, routerId, route: $activeRoute });\r\n\t}\r\n\r\n\tif (isTopLevelRouter) {\r\n\t\t// The topmost Router in the tree is responsible for updating\r\n\t\t// the location store and supplying it through context.\r\n\t\tonMount(() => {\r\n\t\t\tconst unlisten = history.listen(changedHistory => {\r\n\t\t\t\tconst normalizedLocation = normalizeLocation(\r\n\t\t\t\t\tchangedHistory.location,\r\n\t\t\t\t\tnormalizedBasepath,\r\n\t\t\t\t);\r\n\t\t\t\tprevLocation.set($location);\r\n\t\t\t\tlocation.set(normalizedLocation);\r\n\t\t\t});\r\n\r\n\t\t\treturn unlisten;\r\n\t\t});\r\n\r\n\t\tsetContext(LOCATION, location);\r\n\t}\r\n\r\n\tsetContext(ROUTER, {\r\n\t\tactiveRoute,\r\n\t\tregisterRoute,\r\n\t\tunregisterRoute,\r\n\t\tmanageFocus,\r\n\t\tlevel,\r\n\t\tid: routerId,\r\n\t\thistory: isTopLevelRouter ? history : routerContext.history,\r\n\t\tbasepath: isTopLevelRouter ? normalizedBasepath : routerContext.basepath,\r\n\t\tdisableInlineStyles: shouldDisableInlineStyles,\r\n\t});\r\n</script>\r\n\r\n<div\r\n\t{...createMarkerProps(shouldDisableInlineStyles)}\r\n\tdata-svnav-router={routerId}\r\n/>\r\n\r\n<slot />\r\n\r\n{#if isTopLevelRouter && manageFocus && a11yConfig.announcements}\r\n\t<div\r\n\t\trole=\"status\"\r\n\t\taria-atomic=\"true\"\r\n\t\taria-live=\"polite\"\r\n\t\tdata-svnav-announcer\r\n\t\t{...createInlineStyle(shouldDisableInlineStyles, visuallyHiddenStyle)}\r\n\t>\r\n\t\t{$announcementText}\r\n\t</div>\r\n{/if}\r\n", "import { getContext, onDestroy, tick } from \"svelte\";\r\nimport { derived, get, writable } from \"svelte/store\";\r\nimport { LOCATION, ROUTER, ROUTE, ROUTE_PARAMS, FOCUS_ELEM } from \"./contexts\";\r\nimport { resolveLink, match, normalizeLocation } from \"./routes\";\r\nimport { isNumber } from \"./utils\";\r\nimport {\r\n\tfail,\r\n\tcreateLabel,\r\n\tUSE_FOCUS_ID,\r\n\tROUTER_ID,\r\n\tUSE_LOCATION_ID,\r\n\tROUTE_ID,\r\n\tUSE_RESOLVE_ID,\r\n\tUSE_RESOLVABLE_ID,\r\n\tUSE_NAVIGATE_ID,\r\n\tUSE_MATCH_ID,\r\n\tUSE_PARAMS_ID,\r\n} from \"./warning\";\r\n\r\n/**\r\n * Check if a component or hook have been created outside of a\r\n * context providing component\r\n * @param {number} componentId\r\n * @param {*} props\r\n * @param {string?} ctxKey\r\n * @param {number?} ctxProviderId\r\n */\r\nexport function usePreflightCheck(\r\n\tcomponentId,\r\n\tprops,\r\n\tctxKey = ROUTER,\r\n\tctxProviderId = ROUTER_ID,\r\n) {\r\n\tconst ctx = getContext(ctxKey);\r\n\tif (!ctx) {\r\n\t\tfail(\r\n\t\t\tcomponentId,\r\n\t\t\tlabel =>\r\n\t\t\t\t`You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`,\r\n\t\t\tprops,\r\n\t\t);\r\n\t}\r\n}\r\n\r\nconst toReadonly = ctx => {\r\n\tconst { subscribe } = getContext(ctx);\r\n\treturn { subscribe };\r\n};\r\n\r\n/**\r\n * Access the current location via a readable store.\r\n * @returns {import(\"svelte/store\").Readable<{\r\n    pathname: string;\r\n    search: string;\r\n    hash: string;\r\n    state: {};\r\n  }>}\r\n *\r\n * @example\r\n  ```html\r\n  <script>\r\n    import { useLocation } from \"svelte-navigator\";\r\n\r\n    const location = useLocation();\r\n\r\n    $: console.log($location);\r\n    // {\r\n    //   pathname: \"/blog\",\r\n    //   search: \"?id=123\",\r\n    //   hash: \"#comments\",\r\n    //   state: {}\r\n    // }\r\n  </script>\r\n  ```\r\n */\r\nexport function useLocation() {\r\n\tusePreflightCheck(USE_LOCATION_ID);\r\n\treturn toReadonly(LOCATION);\r\n}\r\n\r\n/**\r\n * @typedef {{\r\n    path: string;\r\n    fullPath: string;\r\n    uri: string;\r\n    params: {};\r\n  }} RouteMatch\r\n */\r\n\r\n/**\r\n * @typedef {import(\"svelte/store\").Readable<RouteMatch|null>} RouteMatchStore\r\n */\r\n\r\n/**\r\n * Access the history of top level Router.\r\n */\r\nexport function useHistory() {\r\n\tconst { history } = getContext(ROUTER);\r\n\treturn history;\r\n}\r\n\r\n/**\r\n * Access the base of the parent Route.\r\n */\r\nexport function useRouteBase() {\r\n\tconst route = getContext(ROUTE);\r\n\treturn route ? derived(route, _route => _route.base) : writable(\"/\");\r\n}\r\n\r\n/**\r\n * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.\r\n * It is used under the hood in `Link` and `useNavigate`.\r\n * You can use it to manually resolve links, when using the `link` or `links` actions.\r\n *\r\n * @returns {(path: string) => string}\r\n *\r\n * @example\r\n  ```html\r\n  <script>\r\n    import { link, useResolve } from \"svelte-navigator\";\r\n\r\n    const resolve = useResolve();\r\n    // `resolvedLink` will be resolved relative to its parent Route\r\n    // and the Routers `basepath`\r\n    const resolvedLink = resolve(\"relativePath\");\r\n  </script>\r\n\r\n  <a href={resolvedLink} use:link>Relative link</a>\r\n  ```\r\n */\r\nexport function useResolve() {\r\n\tusePreflightCheck(USE_RESOLVE_ID);\r\n\tconst routeBase = useRouteBase();\r\n\tconst { basepath: appBase } = getContext(ROUTER);\r\n\t/**\r\n\t * Resolves the path relative to the current route and basepath.\r\n\t *\r\n\t * @param {string} path The path to resolve\r\n\t * @returns {string} The resolved path\r\n\t */\r\n\tconst resolve = path => resolveLink(path, get(routeBase), appBase);\r\n\treturn resolve;\r\n}\r\n\r\n/**\r\n * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.\r\n * It is used under the hood in `Link` and `useNavigate`.\r\n * You can use it to manually resolve links, when using the `link` or `links` actions.\r\n *\r\n * @returns {import(\"svelte/store\").Readable<string>}\r\n *\r\n * @example\r\n  ```html\r\n  <script>\r\n    import { link, useResolvable } from \"svelte-navigator\";\r\n\r\n    // `resolvedLink` will be resolved relative to its parent Route\r\n    // and the Routers `basepath`.\r\n    const resolvedLink = useResolvable(\"relativePath\");\r\n  </script>\r\n\r\n  <a href={$resolvedLink} use:link>Relative link</a>\r\n  ```\r\n */\r\nexport function useResolvable(path) {\r\n\tusePreflightCheck(USE_RESOLVABLE_ID);\r\n\tconst routeBase = useRouteBase();\r\n\tconst { basepath: appBase } = getContext(ROUTER);\r\n\treturn derived(routeBase, _routeBase =>\r\n\t\tresolveLink(path, _routeBase, appBase),\r\n\t);\r\n}\r\n\r\n/**\r\n * A hook, that returns a context-aware version of `navigate`.\r\n * It will automatically resolve the given link relative to the current Route.\r\n * It will also resolve a link against the `basepath` of the Router.\r\n *\r\n * @example\r\n  ```html\r\n  <!-- App.svelte -->\r\n  <script>\r\n    import { link, Route } from \"svelte-navigator\";\r\n    import RouteComponent from \"./RouteComponent.svelte\";\r\n  </script>\r\n\r\n  <Router>\r\n    <Route path=\"route1\">\r\n      <RouteComponent />\r\n    </Route>\r\n    <!-- ... -->\r\n  </Router>\r\n\r\n  <!-- RouteComponent.svelte -->\r\n  <script>\r\n    import { useNavigate } from \"svelte-navigator\";\r\n\r\n    const navigate = useNavigate();\r\n  </script>\r\n\r\n  <button on:click=\"{() => navigate('relativePath')}\">\r\n    go to /route1/relativePath\r\n  </button>\r\n  <button on:click=\"{() => navigate('/absolutePath')}\">\r\n    go to /absolutePath\r\n  </button>\r\n  ```\r\n  *\r\n  * @example\r\n  ```html\r\n  <!-- App.svelte -->\r\n  <script>\r\n    import { link, Route } from \"svelte-navigator\";\r\n    import RouteComponent from \"./RouteComponent.svelte\";\r\n  </script>\r\n\r\n  <Router basepath=\"/base\">\r\n    <Route path=\"route1\">\r\n      <RouteComponent />\r\n    </Route>\r\n    <!-- ... -->\r\n  </Router>\r\n\r\n  <!-- RouteComponent.svelte -->\r\n  <script>\r\n    import { useNavigate } from \"svelte-navigator\";\r\n\r\n    const navigate = useNavigate();\r\n  </script>\r\n\r\n  <button on:click=\"{() => navigate('relativePath')}\">\r\n    go to /base/route1/relativePath\r\n  </button>\r\n  <button on:click=\"{() => navigate('/absolutePath')}\">\r\n    go to /base/absolutePath\r\n  </button>\r\n  ```\r\n */\r\nexport function useNavigate() {\r\n\tusePreflightCheck(USE_NAVIGATE_ID);\r\n\tconst resolve = useResolve();\r\n\tconst { navigate } = useHistory();\r\n\t/**\r\n\t * Navigate to a new route.\r\n\t * Resolves the link relative to the current route and basepath.\r\n\t *\r\n\t * @param {string|number} to The path to navigate to.\r\n\t *\r\n\t * If `to` is a number we will navigate to the stack entry index + `to`\r\n\t * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)\r\n\t * @param {Object} options\r\n\t * @param {*} [options.state]\r\n\t * @param {boolean} [options.replace=false]\r\n\t */\r\n\tconst navigateRelative = (to, options) => {\r\n\t\t// If to is a number, we navigate to the target stack entry via `history.go`.\r\n\t\t// Otherwise resolve the link\r\n\t\tconst target = isNumber(to) ? to : resolve(to);\r\n\t\treturn navigate(target, options);\r\n\t};\r\n\treturn navigateRelative;\r\n}\r\n\r\n/**\r\n * Use Svelte Navigators matching without needing to use a Route.\r\n * Returns a readable store with the potential match,\r\n * that changes, when the location changes.\r\n *\r\n * The provided path will be resolved relatively,\r\n * as you're used to with all paths in Svelte Navigator\r\n *\r\n * @param {string} path The path, to match against.\r\n * It works just like a Route path\r\n * @returns {RouteMatchStore} The matched route.\r\n * Returns `null`, when nothing could be matched\r\n *\r\n * @example\r\n  ```html\r\n  <script>\r\n    import { useMatch } from \"svelte-navigator\";\r\n\r\n    const relativeMatch = useMatch(\"relative/path/:to/*somewhere\");\r\n    const absoluteMatch = useMatch(\"/absolute/path/:to/*somewhere\");\r\n\r\n    $: console.log($relativeMatch.params.to);\r\n    $: console.log($absoluteMatch.params.somewhere);\r\n  </script>\r\n  ```\r\n */\r\nexport function useMatch(path) {\r\n\tusePreflightCheck(USE_MATCH_ID);\r\n\tconst location = useLocation();\r\n\tconst resolve = useResolve();\r\n\tconst { basepath: appBase } = getContext(ROUTER);\r\n\tconst resolvedPath = resolve(path);\r\n\tconst { pathname: fullPath } = normalizeLocation(\r\n\t\t{ pathname: resolvedPath },\r\n\t\tappBase,\r\n\t);\r\n\treturn derived(location, loc => match({ fullPath, path }, loc.pathname));\r\n}\r\n\r\n/**\r\n * Access the parent Routes matched params and wildcards\r\n * @returns {import(\"svelte/store\").Readable<{\r\n     [param: string]: any;\r\n   }>} A readable store containing the matched parameters and wildcards\r\n *\r\n * @example\r\n  ```html\r\n  <!--\r\n    Somewhere inside <Route path=\"user/:id/*splat\" />\r\n    with a current url of \"/myApp/user/123/pauls-profile\"\r\n  -->\r\n  <script>\r\n    import { useParams } from \"svelte-navigator\";\r\n\r\n    const params = useParams();\r\n\r\n    $: console.log($params); // -> { id: \"123\", splat: \"pauls-profile\" }\r\n  </script>\r\n\r\n  <h3>Welcome user {$params.id}! bleep bloop...</h3>\r\n  ```\r\n */\r\nexport function useParams() {\r\n\tusePreflightCheck(USE_PARAMS_ID, null, ROUTE, ROUTE_ID);\r\n\treturn toReadonly(ROUTE_PARAMS);\r\n}\r\n\r\n/**\r\n * Provide a custom element to focus, when the parent route is visited.\r\n * It returns the `registerFocus` function you can call manually with an\r\n * Element or use as a Svelte action via the `use` directive.\r\n *\r\n * @example\r\n  ```html\r\n  <!-- Using `registerFocus` as a Svelte action: -->\r\n  <!-- Somewhere inside a Route -->\r\n  <script>\r\n    import { useFocus } from \"svelte-navigator\";\r\n\r\n    const registerFocus = useFocus();\r\n  </script>\r\n\r\n  <h1>Don't worry about me...</h1>\r\n  <p use:registerFocus>Here, look at me!</p>\r\n  ```\r\n  * @example\r\n  ```html\r\n  <!-- Calling `registerFocus` manually: -->\r\n  <!-- Somewhere inside a Route -->\r\n  <script>\r\n    import { onMount } from \"svelte\";\r\n    import { useFocus } from \"svelte-navigator\";\r\n\r\n    const registerFocus = useFocus();\r\n\r\n    let focusElement;\r\n\r\n    onMount(() => registerFocus(focusElement))\r\n  </script>\r\n\r\n  <h1>Don't worry about me...</h1>\r\n  <p bind:this={focusElement}>Here, look at me!</p>\r\n  ```\r\n  * @example\r\n  ```html\r\n  <!-- Using `registerFocus` asyncronously: -->\r\n  <!-- Somewhere inside a Route -->\r\n  <script>\r\n    import { onMount } from \"svelte\";\r\n    import { useFocus } from \"svelte-navigator\";\r\n\r\n    const registerFocus = useFocus();\r\n\r\n    const lazyImport = import(\"./MyComponent.svelte\").then(module => module.default);\r\n  </script>\r\n\r\n  {#await lazyImport then MyComponent}\r\n    <MyComponent {registerFocus} />\r\n  {/await}\r\n\r\n  <!-- MyComponent.svelte -->\r\n  <script>\r\n    export let registerFocus;\r\n  </script>\r\n\r\n  <h1 use:registerFocus>Hi there!</h1>\r\n  ```\r\n */\r\nexport function useFocus() {\r\n\tusePreflightCheck(USE_FOCUS_ID, null, ROUTE, ROUTE_ID);\r\n\tconst location = useLocation();\r\n\tconst focusElement = getContext(FOCUS_ELEM);\r\n\r\n\tlet resolve;\r\n\tconst unsubscribe = location.subscribe(() => {\r\n\t\tconst lazyElement = new Promise(_resolve => {\r\n\t\t\tresolve = _resolve;\r\n\t\t});\r\n\t\tfocusElement.set(lazyElement);\r\n\t});\r\n\r\n\tonDestroy(unsubscribe);\r\n\r\n\treturn node => {\r\n\t\tlet unmounted = false;\r\n\t\tconst innerUnsubscribe = location.subscribe(() => {\r\n\t\t\ttick().then(() => {\r\n\t\t\t\tif (!unmounted) {\r\n\t\t\t\t\tresolve(node);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t\treturn {\r\n\t\t\tdestroy() {\r\n\t\t\t\tunmounted = true;\r\n\t\t\t\tinnerUnsubscribe();\r\n\t\t\t},\r\n\t\t};\r\n\t};\r\n}\r\n", "<script context=\"module\">\r\n\t// eslint-disable-next-line import/order\r\n\timport { createCounter, createMarkerProps } from \"./utils\";\r\n\r\n\tconst createId = createCounter();\r\n</script>\r\n\r\n<script>\r\n\t/*\r\n\t * Adapted from https://github.com/EmilTholin/svelte-routing\r\n\t *\r\n\t * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\r\n\t */\r\n\r\n\timport { getContext, onDestroy, setContext } from \"svelte\";\r\n\timport { writable, get } from \"svelte/store\";\r\n\timport Router from \"./Router.svelte\";\r\n\timport { ROUTER, ROUTE, ROUTE_PARAMS, FOCUS_ELEM } from \"./contexts\";\r\n\timport {\r\n\t\tuseLocation,\r\n\t\tuseNavigate,\r\n\t\tuseRouteBase,\r\n\t\tusePreflightCheck,\r\n\t} from \"./hooks\";\r\n\timport { isSSR } from \"./utils\";\r\n\timport { extractBaseUri } from \"./routes\";\r\n\timport { join } from \"./paths\";\r\n\timport { ROUTE_ID } from \"./warning\";\r\n\r\n\texport let path = \"\";\r\n\texport let component = null;\r\n\texport let meta = {};\r\n\texport let primary = true;\r\n\r\n\tusePreflightCheck(ROUTE_ID, $$props);\r\n\r\n\tconst id = createId();\r\n\r\n\tconst { registerRoute, unregisterRoute, activeRoute, disableInlineStyles } =\r\n\t\tgetContext(ROUTER);\r\n\tconst parentBase = useRouteBase();\r\n\tconst location = useLocation();\r\n\tconst focusElement = writable(null);\r\n\r\n\t// In SSR we cannot wait for $activeRoute to update,\r\n\t// so we use the match returned from `registerRoute` instead\r\n\tlet ssrMatch;\r\n\r\n\tconst route = writable();\r\n\t$: {\r\n\t\t// The route store will be re-computed whenever props, location or parentBase change\r\n\t\tconst isDefault = path === \"\";\r\n\t\tconst rawBase = join($parentBase, path);\r\n\t\tconst updatedRoute = {\r\n\t\t\tid,\r\n\t\t\tpath,\r\n\t\t\tmeta,\r\n\t\t\t// If no path prop is given, this Route will act as the default Route\r\n\t\t\t// that is rendered if no other Route in the Router is a match\r\n\t\t\tdefault: isDefault,\r\n\t\t\tfullPath: isDefault ? \"\" : rawBase,\r\n\t\t\tbase: isDefault\r\n\t\t\t\t? $parentBase\r\n\t\t\t\t: extractBaseUri(rawBase, $location.pathname),\r\n\t\t\tprimary,\r\n\t\t\tfocusElement,\r\n\t\t};\r\n\t\troute.set(updatedRoute);\r\n\t\t// If we're in SSR mode and the Route matches,\r\n\t\t// `registerRoute` will return the match\r\n\t\tssrMatch = registerRoute(updatedRoute);\r\n\t}\r\n\r\n\t$: isActive = !!(ssrMatch || ($activeRoute && $activeRoute.id === id));\r\n\r\n\tconst params = writable({});\r\n\t$: if (isActive) {\r\n\t\tconst { params: activeParams } = ssrMatch || $activeRoute;\r\n\t\tparams.set(activeParams);\r\n\t}\r\n\r\n\tsetContext(ROUTE, route);\r\n\tsetContext(ROUTE_PARAMS, params);\r\n\tsetContext(FOCUS_ELEM, focusElement);\r\n\r\n\t// We need to call useNavigate after the route is set,\r\n\t// so we can use the routes path for link resolution\r\n\tconst navigate = useNavigate();\r\n\r\n\t// There is no need to unregister Routes in SSR since it will all be\r\n\t// thrown away anyway\r\n\tif (!isSSR) {\r\n\t\tonDestroy(() => unregisterRoute(id));\r\n\t}\r\n</script>\r\n\r\n<div {...createMarkerProps(disableInlineStyles)} data-svnav-route-start={id} />\r\n{#if isActive}\r\n\t<Router {primary}>\r\n\t\t<!--\r\n      `$params` always returns `{}` in SSR in Route, because it will\r\n      update after component initialisation has already happend.\r\n      `get(params)` always works, but is not reactive, so we can't\r\n      use it in client rendered mode\r\n    -->\r\n\t\t{#if component !== null}\r\n\t\t\t<svelte:component\r\n\t\t\t\tthis={component}\r\n\t\t\t\tlocation={$location}\r\n\t\t\t\t{navigate}\r\n\t\t\t\t{...isSSR ? get(params) : $params}\r\n\t\t\t\t{...$$restProps}\r\n\t\t\t/>\r\n\t\t{:else}\r\n\t\t\t<slot\r\n\t\t\t\tparams={isSSR ? get(params) : $params}\r\n\t\t\t\tlocation={$location}\r\n\t\t\t\t{navigate}\r\n\t\t\t/>\r\n\t\t{/if}\r\n\t</Router>\r\n{/if}\r\n<div {...createMarkerProps(disableInlineStyles)} data-svnav-route-end={id} />\r\n", "<script>\r\n\t/*\r\n\t * Adapted from https://github.com/EmilTholin/svelte-routing\r\n\t *\r\n\t * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\r\n\t */\r\n\r\n\timport { createEventDispatcher } from \"svelte\";\r\n\timport {\r\n\t\tuseLocation,\r\n\t\tuseResolve,\r\n\t\tuseHistory,\r\n\t\tusePreflightCheck,\r\n\t} from \"./hooks\";\r\n\timport { shouldNavigate, isFunction } from \"./utils\";\r\n\timport { startsWith } from \"./paths\";\r\n\timport { LINK_ID } from \"./warning\";\r\n\timport { parsePath, stringifyPath } from \"./routes\";\r\n\r\n\texport let to;\r\n\texport let replace = false;\r\n\texport let state = {};\r\n\texport let getProps = null;\r\n\r\n\tusePreflightCheck(LINK_ID, $$props);\r\n\r\n\tconst location = useLocation();\r\n\tconst dispatch = createEventDispatcher();\r\n\tconst resolve = useResolve();\r\n\tconst { navigate } = useHistory();\r\n\r\n\t// We need to pass location here to force re-resolution of the link,\r\n\t// when the pathname changes. Otherwise we could end up with stale path params,\r\n\t// when for example an :id changes in the parent Routes path\r\n\t$: href = resolve(to, $location);\r\n\t$: isPartiallyCurrent = startsWith($location.pathname, href);\r\n\t$: isCurrent = href === $location.pathname;\r\n\t$: isExactCurrent = parsePath(href) === stringifyPath($location);\r\n\t$: ariaCurrent = isCurrent ? { \"aria-current\": \"page\" } : {};\r\n\t$: props = (() => {\r\n\t\tif (isFunction(getProps)) {\r\n\t\t\tconst dynamicProps = getProps({\r\n\t\t\t\tlocation: $location,\r\n\t\t\t\thref,\r\n\t\t\t\tisPartiallyCurrent,\r\n\t\t\t\tisCurrent,\r\n\t\t\t});\r\n\t\t\treturn { ...$$restProps, ...dynamicProps };\r\n\t\t}\r\n\t\treturn $$restProps;\r\n\t})();\r\n\r\n\tfunction onClick(event) {\r\n\t\tdispatch(\"click\", event);\r\n\r\n\t\tif (shouldNavigate(event)) {\r\n\t\t\tevent.preventDefault();\r\n\t\t\t// Don't push another entry to the history stack when the user\r\n\t\t\t// clicks on a Link to the page they are currently on.\r\n\t\t\tconst shouldReplace = isExactCurrent || replace;\r\n\t\t\tnavigate(href, { state, replace: shouldReplace });\r\n\t\t}\r\n\t}\r\n</script>\r\n\r\n<a {href} {...ariaCurrent} on:click={onClick} {...props}>\r\n\t<slot />\r\n</a>\r\n", "/*\r\n * Adapted from https://github.com/EmilTholin/svelte-routing\r\n *\r\n * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\r\n */\r\n\r\nimport { navigate as defaultNavigate } from \"./history\";\r\nimport { shouldNavigate, findClosest, addListener, isFunction } from \"./utils\";\r\n\r\nconst createAction =\r\n\tgetAnchor =>\r\n\t(node, navigate = defaultNavigate) => {\r\n\t\tconst handleClick = event => {\r\n\t\t\tconst anchor = getAnchor(event);\r\n\t\t\tif (anchor && anchor.target === \"\" && shouldNavigate(event)) {\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t\tconst to = anchor.pathname + anchor.search + anchor.hash;\r\n\t\t\t\tnavigate(to, { replace: anchor.hasAttribute(\"replace\") });\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst unlisten = addListener(node, \"click\", handleClick);\r\n\t\treturn { destroy: unlisten };\r\n\t};\r\n\r\n// prettier-ignore\r\n/**\r\n * A link action that can be added to <a href=\"\"> tags rather\r\n * than using the <Link> component.\r\n *\r\n * Example:\r\n * ```html\r\n * <a href=\"/post/{postId}\" use:link>{post.title}</a>\r\n * ```\r\n */\r\nexport const link = /*#__PURE__*/createAction(event => event.currentTarget); // eslint-disable-line spaced-comment, max-len\r\n\r\n// prettier-ignore\r\n/**\r\n * An action to be added at a root element of your application to\r\n * capture all relative links and push them onto the history stack.\r\n *\r\n * Example:\r\n * ```html\r\n * <div use:links>\r\n *   <Router>\r\n *     <Route path=\"/\" component={Home} />\r\n *     <Route path=\"/p/:projectId/:docId\" component={ProjectScreen} />\r\n *     {#each projects as project}\r\n *       <a href=\"/p/{project.id}\">{project.title}</a>\r\n *     {/each}\r\n *   </Router>\r\n * </div>\r\n * ```\r\n */\r\nexport const links = /*#__PURE__*/createAction(event => { // eslint-disable-line spaced-comment\r\n  const anchor = findClosest(\"A\", event.target);\r\n  if (\r\n    anchor &&\r\n    isFunction(anchor.hasAttribute) &&\r\n    !anchor.hasAttribute(\"noroute\")\r\n  ) {\r\n    return anchor;\r\n  }\r\n  return null;\r\n});\r\n"],
  "mappings": "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",
  "names": ["element", "query", "uri", "ctx", "resolve", "navigate", "ctx", "create_if_block", "createId", "navigate", "ctx", "resolve", "navigate", "navigate"]
}
